<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Arm-2D: How to Use Tile Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="footer.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="version.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../version.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 55px;">
  <td id="projectlogo" style="padding: 1.5em;"><img alt="Logo" src="arm.png"/></td>
  <td style="padding-left: 1em; padding-bottom: 1em;padding-top: 1em;">
   <div id="projectname">Arm-2D
   &#160;<span id="projectnumber"><script type="text/javascript">
     <!--
     writeHeader.call(this);
     writeVersionDropdown(this);
     //-->
    </script>
   </span>
   </div>
   <div id="projectbrief">2D Image Processing Library for Cortex-M Processors</div>
  </td>
  <!--END !PROJECT_NAME-->
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('use_tile.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">How to Use Tile Operations </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_how_to_use_tile_operations"></a></p>
<h1><a class="anchor" id="autotoc_md110"></a>
1 Overview</h1>
<p >The Tile Operation is the most fundamental API category of the Arm-2d. It consists of three sub-categories:</p>
<ul>
<li>Basic: for tile creation, editing and maintenance<ul>
<li><b>Generate a child tile</b> based on a specified tile and a region within the target tile.</li>
<li><b>Get the root tile</b> of a given one.</li>
<li><b>Check</b> whether a given tile is a <b>root tile</b> or not</li>
<li><b>Intersect two given regions</b> and generate a clipped region.</li>
</ul>
</li>
<li>Tile Copy<ul>
<li><b>Copy</b> a source tile to a target tile with specified region within the target tile</li>
<li><b>Fill</b> a target tile with a specified source tile</li>
</ul>
</li>
<li>Tile Copy with transparency colour, i.e. <b>colour keying</b><ul>
<li>Copy a source tile to a target tile with a given region inside the target tile, and during this process, once a specified colour is read from the source tile, the foreground pixel will be ignored. This is very useful to render non-rectangular visual elements.</li>
</ul>
</li>
<li>Implement Partial Framebuffer support<ul>
<li>By drawing the same content several times, it is possible to flush a complete frame to a big screen (with arbitrary resolution) using just a fraction of the frame buffer. This time-space exchanging scheme is called Partial Frame Buffer (PFB). <b>While using PFB in the low level, the GUI built upon Arm-2d APIs can generally act as if a complete framebuffer is used</b>.</li>
</ul>
</li>
</ul>
<p >All related definitions are listed in the interface header file <em><b>Arm_2d_tile.h</b></em> and the default C implementation and Helium implementation can be found in <em><b>Arm_2d_tile.c</b></em>.</p>
<h1><a class="anchor" id="autotoc_md111"></a>
2 Key Scenarios, Patterns and Use Cases</h1>
<h2><a class="anchor" id="autotoc_md112"></a>
2.1 Normal Usage</h2>
<p >A Root tile is a kind of tiles that directly contain the display buffer, and its feature bit <em><b>bIsRoot</b></em> is set, according to the pixel types used in the display buffer to which corresponding pointers should be used.</p>
<p >It is worth emphasizing that for a root Tile, its Location coordinate must be <em><b>(0,0)</b></em>; otherwise, it is considered illegal.</p>
<p >With the help of <a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">C99 designator</a>, a tile structure can be initialised clearly and easily. The following example shows a root tile <em><b>c_tPictureCMSISLogo</b></em> representing a <em><b>RGBA8888</b></em> bitmap stored in a constant array called <em><b>c_bmpCMSISLogo[]</b></em>. Note that because the bitmap and the tile structure are designated as constants, it is highly likely that a compiler will use ROM rather than RAM to store them and keep a small RAM footprint.</p>
<div class="fragment"><div class="line"><span class="comment">/*! picture cmsis_logo */</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> uint8_t c_bmpCMSISLogo[163 * 65 * <span class="keyword">sizeof</span>(uint32_t)];</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">static</span> <a class="code hl_struct" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> c_tPictureCMSISLogo = {</div>
<div class="line">    .tRegion = {</div>
<div class="line">        .tSize = {</div>
<div class="line">            .iWidth = 163,</div>
<div class="line">            .iHeight = 65</div>
<div class="line">        },</div>
<div class="line">    },</div>
<div class="line">    .tInfo = {</div>
<div class="line">        .bIsRoot = <span class="keyword">true</span>,</div>
<div class="line">        .bHasEnforcedColour = <span class="keyword">true</span>,</div>
<div class="line">        .tColourInfo = {</div>
<div class="line">            .chScheme = ARM_2D_COLOUR_RGBA8888,</div>
<div class="line">        },</div>
<div class="line">    },</div>
<div class="line">    .pwBuffer = (uint32_t *)c_bmpCMSISLogo,</div>
<div class="line">};</div>
</div><!-- fragment --><p >In fact, with the help of some macro templates, we can use Tile to implement framebuffers with a given size:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define __declare_tile(__NAME)                                                  \</span></div>
<div class="line"><span class="preprocessor">            extern const arm_2d_tile_t __NAME;</span></div>
<div class="line"><span class="preprocessor">#define declare_tile(__NAME)            __declare_tile(__NAME)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define dcl_fb(__name)                  declare_tile(__name)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define __impl_fb(__name, __width, __height, __type, ...)                       \</span></div>
<div class="line"><span class="preprocessor">            ARM_NOINIT static __type                                            \</span></div>
<div class="line"><span class="preprocessor">                __name##Buffer[(__width) * (__height)];                         \</span></div>
<div class="line"><span class="preprocessor">            const arm_2d_tile_t __name = {                                      \</span></div>
<div class="line"><span class="preprocessor">                .tRegion = {                                                    \</span></div>
<div class="line"><span class="preprocessor">                    .tSize = {(__width), (__height)},                           \</span></div>
<div class="line"><span class="preprocessor">                },                                                              \</span></div>
<div class="line"><span class="preprocessor">                .tInfo.bIsRoot = true,                                          \</span></div>
<div class="line"><span class="preprocessor">                .pchBuffer = (uint8_t *)__name##Buffer,                         \</span></div>
<div class="line"><span class="preprocessor">                __VA_ARGS__                                                     \</span></div>
<div class="line"><span class="preprocessor">            }</span></div>
<div class="line">            </div>
<div class="line"><span class="preprocessor">#define impl_fb(__name, __width, __height, __type, ...)                         \</span></div>
<div class="line"><span class="preprocessor">            __impl_fb(__name, __width, __height, __type, ##__VA_ARGS__)</span></div>
</div><!-- fragment --><p >For example, we can create two framebuffers with size <b>100*100</b> and <em><b>200*50</b></em> respectively and using colour <em><b><a class="el" href="group__gKernel.html#unionarm__2d__color__rgb565__t" title="the colour type for rgb565">arm_2d_color_rgb565_t</a></b></em> for pixels:</p>
<div class="fragment"><div class="line">dcl_fb(c_tLayerA)</div>
<div class="line">implement_tile(c_tLayerA, 100, 100, <a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__rgb565__t" title="the colour type for rgb565">arm_2d_color_rgb565_t</a>);</div>
<div class="line"> </div>
<div class="line">dcl_fb(c_tLayerB)</div>
<div class="line">implement_tile(c_tLayerB, 200, 50, <a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__rgb565__t" title="the colour type for rgb565">arm_2d_color_rgb565_t</a>);</div>
</div><!-- fragment --><p >These layers are stored in RAM, which are used as sources and targets for 2D operations.</p>
<p >Note that in the aforementioned macro template, we use <em><b>ARM_NOINIT</b></em> to decorate the display buffer, its definition is shown below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ARM_NOINIT</span></div>
<div class="line"><span class="preprocessor">#if     defined(__IS_COMPILER_ARM_COMPILER_5__)</span></div>
<div class="line"><span class="preprocessor">#   define ARM_NOINIT           __attribute__( ( section( &quot;.bss.noinit&quot;</span>),zero_init) )</div>
<div class="line"><span class="preprocessor">#elif   defined(__IS_COMPILER_ARM_COMPILER_6__)</span></div>
<div class="line"><span class="preprocessor">#   define ARM_NOINIT           __attribute__( ( section( &quot;.bss.noinit&quot;</span>)) )</div>
<div class="line"><span class="preprocessor">#elif   defined(__IS_COMPILER_IAR__)</span></div>
<div class="line"><span class="preprocessor">#   define ARM_NOINIT           __no_init</span></div>
<div class="line"><span class="preprocessor">#elif   defined(__IS_COMPILER_GCC__) || defined(__IS_COMPILER_LLVM__)</span></div>
<div class="line"><span class="preprocessor">#   define ARM_NOINIT           __attribute__(( __section__( &quot;.bss.noinit&quot;</span>)))</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#   define ARM_NOINIT</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p >It is clear that for the Arm Compiler 5 and Arm Compiler 6, <em><b>ARM_NOINIT</b></em> puts the target variable into a <em><b>ZI</b></em> section called <em><b>".bss.noinit"</b></em> which later should be placed in an execution region with <em><b><a href="https://developer.arm.com/documentation/101754/0616/armlink-Reference/Scatter-File-Syntax/Execution-region-descriptions/Execution-region-attributes">UNINIT</a></b></em> feature in a scatter-script, for example:</p>
<div class="fragment"><div class="line">LR_ROM __ROM_BASE __ROM_SIZE  {                           </div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    ARM_LIB_STACK __RAM1_BASE ALIGN 8 EMPTY __STACK_SIZE { ; Reserve empty region for stack</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    RW_RAM1 +0 __RAM1_RW_SIZE {</div>
<div class="line">        * (+RO-DATA)</div>
<div class="line">        * (+RW +ZI)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    RM_RAM_NOINIT +0 UNINIT {</div>
<div class="line">        * (.bss.noinit)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ARM_LIB_HEAP  __HEAP_BASE ALIGN 8 EMPTY __HEAP_SIZE  { ; Reserve empty region for heap</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md113"></a>
2.1.1 Window/Panel Clipping</h3>
<p ><b>All operations in Arm-2D support region clipping by default</b>, which means users don't have to handle window/panel clipping manually. In rare cases where users have to intersect regions and/or tiles, Arm-2D provides dedicated APIs to facilitate such operations.</p>
<p >For more details, please refer to <b><a href="#41-basic">section 4.1</a></b>.</p>
<h3><a class="anchor" id="autotoc_md114"></a>
2.1.2 Texture Tiling</h3>
<p >Tiling on a target display buffer is one of the most commonly used 2D operations. Arm-2D supports this with tile copy APIs, in which a copy mode can be specified, and <b>Arm_2D_CP_MODE_FILL</b> is used to enable the texture tiling feature.</p>
<p >For more details, please refer to <b><a href="#42-copy-fill-and-xy-mirroring">section 4.2</a></b>.</p>
<h2><a class="anchor" id="autotoc_md115"></a>
2.2 Advanced Usage</h2>
<h3><a class="anchor" id="autotoc_md116"></a>
2.2.1 Partial Frame Buffer (PFB)</h3>
<p >The so-called Partial Frame Buffer is a special use of the Tile Child scheme. It establishes a root Tile for a tiny rectangular display buffer and derives a Child Tile having the same size as the actual screen. In practice, the GUI software in the upper layer uses the Child Tile (with the full-screen size) to draw graphics and blend visual layers. After completing a frame, the PFB that actually saves the pixel information is sent to the LCD driver for a flush. Since FPB only covers a small area, the drawing process aforementioned, in most cases, will be judged as "no need for actual drawing" and skipped. To display the entire screen, we need to repeat this process continuously and adjust the relative Location between FPB and the Child Tile at the beginning of each iteration. For us, it looks like moving FPB line by line on the screen as shown in <b>Figure 2-4</b>.</p>
<p ><b>Figure 2-4 How Partial Frame Buffer Works</b></p>
<p ><img src="Introduction2_3b.png" alt="" class="inline" title="Partial Frame Buffer"/></p>
<p >More details are shown in a dedicated example project located in "***examples/partial_frame_buffer***" directory.</p>
<h1><a class="anchor" id="autotoc_md117"></a>
3 Design Considerations</h1>
<p >Base on the feedbacks collected, design considerations will be documented in the future.</p>
<h1><a class="anchor" id="autotoc_md118"></a>
4 API Table</h1>
<h2><a class="anchor" id="autotoc_md119"></a>
4.1 Basic</h2>
<h3><a class="anchor" id="autotoc_md120"></a>
4.1.1 &lt;strong&gt;arm_2d_tile_generate_child&lt;/strong&gt;</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Topic   </th><th class="markdownTableHeadNone">Content   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Name</b>   </td><td class="markdownTableBodyNone"><em><b>arm_2d_tile_generate_child</b></em>   </td><td class="markdownTableBodyNone">Type: function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <em><b>ptTargetTile</b></em>   </td><td class="markdownTableBodyNone">The address of the target parent tile    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a> * <em><b>ptRegion</b></em>   </td><td class="markdownTableBodyNone">The relative region inside the target tile    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Parameter</b>   </td><td class="markdownTableBodyNone"><a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <em><b>ptOutput</b></em>   </td><td class="markdownTableBodyNone">The address of the new child tile which user should provide.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Parameter</b>   </td><td class="markdownTableBodyNone">bool <em><b>bClipRegion</b></em>   </td><td class="markdownTableBodyNone">Indicates whether clip the region of the new child.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Return Value</b>   </td><td class="markdownTableBodyNone">(<a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> *) <em><b>non-null</b></em>   </td><td class="markdownTableBodyNone">The address of the new child tile provided by the caller.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>NULL</b></em>   </td><td class="markdownTableBodyNone">The relative region has no intersection point with the target tile   </td></tr>
</table>
<p >The behaviour of function <em><b><a class="el" href="group__Tile.html#gae4ee095763b33e1a6e9b0203263edfde" title="generate a child tile from the target tile with a given region">arm_2d_tile_generate_child()</a></b></em> is illustrated in the <b>Figure 4.1</b>. This function will generate a child from a target tile based on a given relative region inside the tile. The user has to provide a buffer for the child tile. If there is no intersection between the tile region and the given relative region, i.e. the relative region is out of the tile region, NULL is returned; otherwise, the provided child tile address is returned.</p>
<p ><b>Figure 4.1 How A Child Tile Is Generated From A Parent Tile</b></p>
<p ><img src="howtousetileoperation_4_1_1_a.png" alt="" class="inline" title="1608223966544"/></p>
<h3><a class="anchor" id="autotoc_md121"></a>
4.1.2 &lt;strong&gt;arm_2d_tile_get_root&lt;/strong&gt;</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Topic   </th><th class="markdownTableHeadNone">Content   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Name</b>   </td><td class="markdownTableBodyNone"><em><b>arm_2d_tile_get_root</b></em>   </td><td class="markdownTableBodyNone">Type: function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <em><b>ptTile</b></em>   </td><td class="markdownTableBodyNone">a given tile    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone"><a class="el" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a> * <em><b>ptValidRegion</b></em>   </td><td class="markdownTableBodyNone">The address of a buffer used to store the valid region information    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone">(<a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> *) <em><b>non-null</b></em>   </td><td class="markdownTableBodyNone">The address of the root tile    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>NULL</b></em>   </td><td class="markdownTableBodyNone">The given tile has no intersection with the root tile, i.e. the given tile is out of the region its root tile.   </td></tr>
</table>
<p >The behaviour of function <em><b><a class="el" href="group__Tile.html#gaa2c90673706f32707b09561eb42e87a9" title="get the root tile and the valid region for a given tile">arm_2d_tile_get_root()</a></b></em> is illustrated in <b>Figure 4.2</b>. This function firstly uses the region of a given tile as the initial value of the valid region and repeats the following steps:</p>
<ol type="1">
<li>Check if current tile is a root tile or not, if so, return the address of current tile.</li>
<li>Update the relative coordinates based on the relative location of current tile</li>
<li>intersect the valid region with current region. If there is no intersection point, return NULL.</li>
<li>Get the parent tile and repeat from step 1</li>
</ol>
<p ><b>Figure 4.2 How A Root Tile Is Retrieved</b></p>
<p ><img src="howtousetileoperation_4_1_2.png" alt="" class="inline" title="1608241452844"/></p>
<p ><b>NOTE:</b> Even if a tile appears inside the root tile, but there could be a string of parents between the target tile and the root, as long as the tile is out of the region of any one of the parents, it is still considered as out of region.</p>
<h3><a class="anchor" id="autotoc_md122"></a>
4.1.3 &lt;strong&gt;arm_2d_is_root_tile&lt;/strong&gt;</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Topic   </th><th class="markdownTableHeadNone">Content   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Name</b>   </td><td class="markdownTableBodyNone"><em><b>arm_2d_is_root_tile</b></em>   </td><td class="markdownTableBodyNone">Type: static inline function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <em><b>ptTile</b></em>   </td><td class="markdownTableBodyNone">The target tile    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>true</b></em>   </td><td class="markdownTableBodyNone">The tile is a root tile, i.e. it contains a display buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>false</b></em>   </td><td class="markdownTableBodyNone">The tile is a child tile, i.e. it has a pointer for a parent tile.   </td></tr>
</table>
<p >This function is used to test whether a given tile is a root one or not.</p>
<h3><a class="anchor" id="autotoc_md123"></a>
4.1.4 &lt;strong&gt;arm_2d_region_intersect&lt;/strong&gt;</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Topic   </th><th class="markdownTableHeadNone">Content   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Name</b>   </td><td class="markdownTableBodyNone"><em><b>arm_2d_region_intersect</b></em>   </td><td class="markdownTableBodyNone">Type: function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a> * <em><b>ptRegionIn0</b></em>   </td><td class="markdownTableBodyNone">The address of the input region 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a> * <em><b>ptRegionIn1</b></em>   </td><td class="markdownTableBodyNone">The address of the input region 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone"><a class="el" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a> * <em><b>ptRegionOut</b></em>   </td><td class="markdownTableBodyNone">The buffer of the output region, this address <b>CAN</b> be NULL.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>true</b></em>   </td><td class="markdownTableBodyNone">The given two input regions have a overlapping region which is stored in a specified buffer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>false</b></em>   </td><td class="markdownTableBodyNone">The given two input regions have no intersection point.   </td></tr>
</table>
<p >The behaviour of function <b>arm_2d_region_intersect</b> is illustrated in <b>Figure 4.3</b>. This function tries to intersect two input regions and output the overlapping area in a user-specified buffer. A Boolean value is returned to indicate that whether two input regions overlap with each other or not. If false is returned, the content in the output buffer is not valid.</p>
<p ><b>NOTE</b>: If you only want to check whether two regions overlap with each other or not, you can omit the region output buffer and use NULL instead.</p>
<p ><b>Figure 4.3 How Region Intersection/Clipping Works</b></p>
<p ><img src="howtousetileoperation_4_1_4_a.png" alt="" class="inline" title="1608227540628"/></p>
<h3><a class="anchor" id="autotoc_md124"></a>
4.1.5 &lt;strong&gt;arm_2d_get_address_and_region_from_tile&lt;/strong&gt;</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Topic   </th><th class="markdownTableHeadNone">Content   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Name</b>   </td><td class="markdownTableBodyNone"><em><b>arm_2d_get_address_and_region_from_tile</b></em>   </td><td class="markdownTableBodyNone">Type: function-like-macro    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone"><em><b>__TILE_PTR</b></em>   </td><td class="markdownTableBodyNone">A pointer which points to the start address of the target tile. This macro will update this pointer with the root tile address.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone"><em><b>__VALID_REGION_NAME</b></em>   </td><td class="markdownTableBodyNone">The name of the region which will be defined by this macro    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone"><em><b>__LOCATION_OFFSET_PTR</b></em>   </td><td class="markdownTableBodyNone">The address of a region which is used to store the relative location of the valid region inside the target tile.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone"><em><b>__TYPE</b></em>   </td><td class="markdownTableBodyNone">The type of the display buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone"><em><b>__BUF_PTR_NAME</b></em>   </td><td class="markdownTableBodyNone">The name of the pointer variable which will be defined by this macro   </td></tr>
</table>
<p >With a given tile, this function-like-macro declare local variables to store the tile region and the start address of the display buffer.</p>
<p ><b>NOTE</b>:</p>
<ol type="1">
<li>When calling this macro, a <em><b>pointer variable</b></em> must be passed as the <em><b>__TILE_PTR</b></em> rather than a constant address of the target tile. It is because the macro calls <em><b><a class="el" href="group__Tile.html#gaa2c90673706f32707b09561eb42e87a9" title="get the root tile and the valid region for a given tile">arm_2d_tile_get_root()</a></b></em> and uses its return value to update the pointer represented by <em><b>__TILE_PTR</b></em>.</li>
<li>Both <em><b>__REGION_NAME</b></em> and <em><b>__BUF_PTR</b></em> <b>MUST</b> be the names of two local variables, which will be declared by this macro. After calling the macro, those local variables will hold the information described in the table above and used by following code within the same braces.</li>
</ol>
<h2><a class="anchor" id="autotoc_md125"></a>
4.2 Copy, Fill and X/Y Mirroring</h2>
<p >Tile Copy and Fill operations are <b>mutually exclusive</b> from each other. Their behaviours are illustrated in <b>Figure 4.4</b>.</p>
<ul>
<li>For normal Tile Copy operations, the function tries to copy a given source tile to a relative region inside a target tile. Since there is no colour calculation involved, both the 16bit and the 32bit version functions can handle all the colour formats with the same data width.</li>
<li>For normal Tile Fill operations, the function tries to fill a given region inside the target tile with the source tile. Since there is no colour calculation involved, both the 16bit and the 32bit version functions can handle all the colour formats with the same data width.</li>
</ul>
<p ><b>Figure 4.4 How Tile Copy and Fill Works</b></p>
<p ><img src="howtousetileoperation_4_2.png" alt="" class="inline" title="1608228421047"/></p>
<p >In addition to the standard Copy and Fill, operations can be combined with X and/or Y mirroring of the source tile (as shown in <b>Figure 4.5</b>). Those combinations together with the standard Copy and Fill are called copy modes. All the legitimate modes are listed in the table below.</p>
<p ><b>Figure 4.5 How Copy with X/Y Mirroring Works</b></p>
<p ><img src="howtousetileoperation_4_2b.png" alt="" class="inline" title="1608325118914"/></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">NOTE    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Arm_2D_CP_MODE_COPY</b>   </td><td class="markdownTableBodyNone">Copy the source tile to the target tile   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Arm_2D_CP_MODE_FILL</b>   </td><td class="markdownTableBodyNone">Fill a target tile with a given source tile   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Arm_2D_CP_MODE_COPY</b> |<br  />
<b>Arm_2D_CP_MODE_X_MIRROR</b>   </td><td class="markdownTableBodyNone">Copy the X-mirrored source tile to the target tile   </td><td class="markdownTableBodyNone"><b>Arm_2D_CP_MODE_COPY</b> can be ignored    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Arm_2D_CP_MODE_COPY</b> |<br  />
<b>Arm_2D_CP_MODE_Y_MIRROR</b>   </td><td class="markdownTableBodyNone">Copy the Y-mirrored source tile to the target tile   </td><td class="markdownTableBodyNone"><b>Arm_2D_CP_MODE_COPY</b> can be ignored    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Arm_2D_CP_MODE_COPY</b> |<br  />
<b>Arm_2D_CP_MODE_X_MIRROR</b> |<br  />
<b>Arm_2D_CP_MODE_Y_MIRROR</b>   </td><td class="markdownTableBodyNone">Copy the X/Y-mirrored source tile to the target tile   </td><td class="markdownTableBodyNone"><b>Arm_2D_CP_MODE_COPY</b> can be ignored    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Arm_2D_CP_MODE_FILL</b> |<br  />
<b>Arm_2D_CP_MODE_X_MIRROR</b>   </td><td class="markdownTableBodyNone">Fill a target tile with a X-mirrored source tile   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Arm_2D_CP_MODE_FILL</b> |<br  />
<b>Arm_2D_CP_MODE_Y_MIRROR</b>   </td><td class="markdownTableBodyNone">Fill a target tile with a Y-mirrored source tile   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Arm_2D_CP_MODE_FILL</b> |<br  />
<b>Arm_2D_CP_MODE_X_MIRROR</b> |<br  />
 <b>Arm_2D_CP_MODE_Y_MIRROR</b>   </td><td class="markdownTableBodyNone">Fill a target tile with a X/Y-mirrored source tile   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<h3><a class="anchor" id="autotoc_md126"></a>
4.2.1 &lt;strong&gt;arm_2d_rgb16_tile_copy&lt;/strong&gt;</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Topic   </th><th class="markdownTableHeadNone">Content   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Name</b>   </td><td class="markdownTableBodyNone"><em><b>arm_2d_rgb16_tile_copy</b></em>   </td><td class="markdownTableBodyNone">Type: function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <em><b>ptSource</b></em>   </td><td class="markdownTableBodyNone">The source tile address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <em><b>ptTarget</b></em>   </td><td class="markdownTableBodyNone">The target tile address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a> * <em><b>ptRegion</b></em>   </td><td class="markdownTableBodyNone">The relative region inside the target tile    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">uint32_t <em><b>wMode</b></em>   </td><td class="markdownTableBodyNone">The mode of the copy, please refer to the copy mode description for more details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone">&lt; 0 or <em><b>arm_fsm_rt_err</b></em> (-1)   </td><td class="markdownTableBodyNone">Error code    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>arm_fsm_rt_cpl</b></em> (0)   </td><td class="markdownTableBodyNone">Operation <b>completed</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>arm_fsm_rt_on_going</b></em> (1)   </td><td class="markdownTableBodyNone">Operation is <b>on-going</b>, and you have to keep calling this function until other value is returned. <br  />
This usually means that the function is working/implemented in <em><b>synchronous mode</b></em>. For more, please refer to <a class="el" href="md_introduction.html">introduction.md</a>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>arm_fsm_rt_asyn</b></em>(3)   </td><td class="markdownTableBodyNone">Operation request has been received; no error found so far. If you have registered your own <em><b>2D-Operation-Complete-Handler</b></em> (<em><b><a class="el" href="group__gKernel.html#structarm__2d__evt__t" title="a type for generic event handling">arm_2d_evt_t</a></b></em>), you don't have to poll this function anymore; the operation result will be passed to you via the event handler; otherwise, you can poll this function until another value is returned. This usually means that the function is working/implemented in <b>asynchronous mode</b>. For more, please refer to <a class="el" href="md_introduction.html">introduction.md</a>.   </td></tr>
</table>
<p >The behaviour of function <b>arm_2d_rgb16_tile_copy</b> is illustrated in <b>Figure 4.4</b>. This function copies a source tile to a specified region inside the target tile or fills the specified region with a given source tile. Several combinations of modes are supported, e.g. copy with X mirroring and/or Y mirroring.</p>
<p ><b>NOTE</b>: This function treats all 16-bit colour formats equally, and <b>NO</b> alpha channel is used, even for RGB1555.</p>
<h3><a class="anchor" id="autotoc_md127"></a>
4.2.2 &lt;strong&gt;arm_2d_rgb32_tile_copy&lt;/strong&gt;</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Topic   </th><th class="markdownTableHeadNone">Content   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Name</b>   </td><td class="markdownTableBodyNone"><em><b>arm_2d_rgb32_tile_copy</b></em>   </td><td class="markdownTableBodyNone">Type: function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <em><b>ptSource</b></em>   </td><td class="markdownTableBodyNone">The source tile address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <em><b>ptTarget</b></em>   </td><td class="markdownTableBodyNone">The target tile address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a> * <em><b>ptRegion</b></em>   </td><td class="markdownTableBodyNone">The relative region inside the target tile    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">uint32_t <em><b>wMode</b></em>   </td><td class="markdownTableBodyNone">The mode of the copy, please refer to the copy mode description for more details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone">&lt; 0 or <em><b>arm_fsm_rt_err</b></em> (-1)   </td><td class="markdownTableBodyNone">Error code    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>arm_fsm_rt_cpl</b></em> (0)   </td><td class="markdownTableBodyNone">Operation <b>completed</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>arm_fsm_rt_on_going</b></em> (1)   </td><td class="markdownTableBodyNone">Operation is <b>on-going</b>, and you have to keep calling this function until another value is returned. This usually means that the function is working/implemented in <b>synchronous mode</b>. For more, please refer to <a class="el" href="md_introduction.html">introduction.md</a>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>arm_fsm_rt_asyn</b></em>(3)   </td><td class="markdownTableBodyNone">Operation request has been received; no error found so far. If you have registered your own <em><b>2D-Operation-Complete-Handler</b></em> (<em><b><a class="el" href="group__gKernel.html#structarm__2d__evt__t" title="a type for generic event handling">arm_2d_evt_t</a></b></em>), you don't have to poll this function anymore; the operation result will be passed to you via the event handler; otherwise, you can poll this function until another value is returned. This usually means that the function is working/implemented in <b>asynchronous mode</b>. For more, please refer to <a class="el" href="md_introduction.html">introduction.md</a>.   </td></tr>
</table>
<p >The behaviour of function <b>arm_2d_rgb32_tile_copy</b> is illustrated in <b>Figure 4.4</b>. This function copies a source tile to a specified region inside the target tile or fills the specified region with a given source tile. Several combinations of modes are supported, e.g. copy with X mirroring and/or Y mirroring.</p>
<p ><b>NOTE</b>: This function treats all 32-bit colour formats equally and <b>NO</b> alpha channel is used, e.g. RGBA8888.</p>
<h2><a class="anchor" id="autotoc_md128"></a>
4.3 Colour Keying</h2>
<p >Colour-keying is a commonly used scheme to implement non-rectangular UI elements, such as round-corner windows/gadgets, floating logos/strings etc. Colour-keying is relatively simple when compared with the (Alpha) Masking scheme provided in the Alpha-blending operation category, which usually requires an 8-bit masking tile that can cover the source tile completely, and each pixel inside the masking tile is used as the alpha channel during an operation. A dedicated masking tile, of course, takes more memory space than a simple key colour. As long as the desired visual area of the source tile contains no pixel in a given key colour, it is much cheaper and quicker to use Colour-Keying rather than (Alpha) Masking.</p>
<p ><b>Figure 4.6 How Copy-with-Colour-Keying Works</b></p>
<p ><img src="howtousetileoperation_4_3.png" alt="" class="inline" title="1608229193551"/></p>
<h3><a class="anchor" id="autotoc_md129"></a>
4.3.1 arm_2d_c8bit_tile_copy_with_colour_keying</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Topic   </th><th class="markdownTableHeadNone">Content   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Name</b>   </td><td class="markdownTableBodyNone"><em><b>arm_2d_c8bit_tile_copy_with_colour_keying</b></em>   </td><td class="markdownTableBodyNone">Type: function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <b>ptSource</b>   </td><td class="markdownTableBodyNone">The source tile address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <b>ptTarget</b>   </td><td class="markdownTableBodyNone">The target tile address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a> * <b>ptRegion</b>   </td><td class="markdownTableBodyNone">The relative region inside the target tile    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">uint8_t <b>chKeyColour</b>   </td><td class="markdownTableBodyNone">The colour used to mask the unwanted part in the source tile    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">uint32_t <em><b>wMode</b></em>   </td><td class="markdownTableBodyNone">The mode of the copy, please refer to the copy mode description for more details.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone">&lt; 0 or <b>arm_fsm_rt_err</b> (-1)   </td><td class="markdownTableBodyNone">Error code    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><b>arm_fsm_rt_cpl</b> (0)   </td><td class="markdownTableBodyNone">Operation <b>completed</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><b>arm_fsm_rt_on_going</b> (1)   </td><td class="markdownTableBodyNone">Operation is <b>on-going</b>, and you have to keep calling this function until another value is returned. This usually means that the function is working/implemented in <b>synchronous mode</b>. For more, please refer to <a class="el" href="md_introduction.html">introduction.md</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><b>arm_fsm_rt_asyn</b>(3)   </td><td class="markdownTableBodyNone">Operation request has been received; no error found so far. If you have registered your own <em><b>2D-Operation-Complete-Handler</b></em> (<em><b><a class="el" href="group__gKernel.html#structarm__2d__evt__t" title="a type for generic event handling">arm_2d_evt_t</a></b></em>), you don't have to poll this function anymore; the operation result will be passed to you via the event handler; otherwise, you can poll this function until another value is returned. This usually means that the function is working/implemented in <b>asynchronous mode</b>. For more, please refer to <a class="el" href="md_introduction.html">introduction.md</a>.   </td></tr>
</table>
<p >The behaviour of function <b>arm_2d_c8bit_tile_copy_with_colour_keying</b> is illustrated in <b>Figure 4.6</b>. This function copies a given source tile to a specified region inside a target tile, during this process, user can specify a colour as the masking colour. If the colour of the pixel read from the source tile is the masking colour, the copy operation for that pixel will be ignored, as the result, i.e. the pixel in the background will be used. This function is dedicated to all colour formats with 8-bit pixel. <br  />
</p>
<p ><b>NOTE</b>: Alpha channels are ignored even if they exist. If you want a version that takes alpha-channel into consideration, please check alpha-blending related APIs.</p>
<h3><a class="anchor" id="autotoc_md130"></a>
4.3.2 arm_2d_rbg16_tile_copy_with_colour_keying</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Topic   </th><th class="markdownTableHeadNone">Content   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Name</b>   </td><td class="markdownTableBodyNone"><em><b>arm_2d_rbg16_tile_copy_with_colour_keying</b></em>   </td><td class="markdownTableBodyNone">Type: function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <b>ptSource</b>   </td><td class="markdownTableBodyNone">The source tile address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <b>ptTarget</b>   </td><td class="markdownTableBodyNone">The target tile address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a> * <b>ptRegion</b>   </td><td class="markdownTableBodyNone">The relative region inside the target tile    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">uint16_t <b>hwMaskColour</b>   </td><td class="markdownTableBodyNone">The colour used to mask the unwanted part in the source tile    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">uint32_t <em><b>wMode</b></em>   </td><td class="markdownTableBodyNone">The mode of the copy, please refer to the copy mode description for more details.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone">&lt; 0 or <b>arm_fsm_rt_err</b> (-1)   </td><td class="markdownTableBodyNone">Error code    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><b>arm_fsm_rt_cpl</b> (0)   </td><td class="markdownTableBodyNone">Operation <b>completed</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><b>arm_fsm_rt_on_going</b> (1)   </td><td class="markdownTableBodyNone">Operation is <b>on-going</b>, and you have to keep calling this function until another value is returned. This usually means that the function is working/implemented in <b>synchronous mode</b>. For more, please refer to <a class="el" href="md_introduction.html">introduction.md</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><b>arm_fsm_rt_asyn</b>(3)   </td><td class="markdownTableBodyNone">Operation request has been received; no error found so far. If you have registered your own <em><b>2D-Operation-Complete-Handler</b></em> (<em><b><a class="el" href="group__gKernel.html#structarm__2d__evt__t" title="a type for generic event handling">arm_2d_evt_t</a></b></em>), you don't have to poll this function anymore; the operation result will be passed to you via the event handler; otherwise, you can poll this function until another value is returned. This usually means that the function is working/implemented in <b>asynchronous mode</b>. For more, please refer to <a class="el" href="md_introduction.html">introduction.md</a>.   </td></tr>
</table>
<p >The behaviour of function <b>arm_2d_rbg16_tile_copy_with_colour_keying</b> is illustrated in <b>Figure 4.6</b>. This function copies a given source tile to a specified region inside a target tile, during this process, user can specify a colour as the masking colour. If the colour of the pixel read from the source tile is the masking colour, the copy operation for that pixel will be ignored, as the result, i.e. the pixel in the background will be used. This function is dedicated to all colour formats with 16-bit pixel. <br  />
</p>
<p ><b>NOTE</b>: Alpha channels are ignored even if they exist. If you want a version that takes alpha-channel into consideration, please check alpha-blending related APIs.</p>
<h3><a class="anchor" id="autotoc_md131"></a>
4.3.3 arm_2d_rbg32_tile_copy_with_colour_keying</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Topic   </th><th class="markdownTableHeadNone">Content   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Name</b>   </td><td class="markdownTableBodyNone"><em><b>arm_2d_rbg32_tile_copy_with_colour_keying</b></em>   </td><td class="markdownTableBodyNone">Type: function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <em><b>ptSource</b></em>   </td><td class="markdownTableBodyNone">The source tile address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> * <em><b>ptTarget</b></em>   </td><td class="markdownTableBodyNone">The target tile address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">const <a class="el" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a> * <em><b>ptRegion</b></em>   </td><td class="markdownTableBodyNone">The relative region inside the target tile    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">uint16_t <em><b>hwMaskColour</b></em>   </td><td class="markdownTableBodyNone">The colour used to mask the unwanted part in the source tile    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Parameter</b>   </td><td class="markdownTableBodyNone">uint32_t <em><b>wMode</b></em>   </td><td class="markdownTableBodyNone">The mode of the copy, please refer to the copy mode description for more details.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone">&lt; 0 or <em><b>arm_fsm_rt_err</b></em> (-1)   </td><td class="markdownTableBodyNone">Error code    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>arm_fsm_rt_cpl</b></em> (0)   </td><td class="markdownTableBodyNone">Operation <b>completed</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>arm_fsm_rt_on_going</b></em> (1)   </td><td class="markdownTableBodyNone">Operation is <b>on-going</b>, and you have to keep calling this function until another value is returned. This usually means that the function is working/implemented in <b>synchronous mode</b>. For more, please refer to <a class="el" href="md_introduction.html">introduction.md</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return Value</b>   </td><td class="markdownTableBodyNone"><em><b>arm_fsm_rt_asyn</b></em>(3)   </td><td class="markdownTableBodyNone">Operation request has been received; no error found so far. If you have registered your own <em><b>2D-Operation-Complete-Handler</b></em> (<em><b><a class="el" href="group__gKernel.html#structarm__2d__evt__t" title="a type for generic event handling">arm_2d_evt_t</a></b></em>), you don't have to poll this function anymore; the operation result will be passed to you via the event handler; otherwise, you can poll this function until another value is returned. This usually means that the function is working/implemented in <b>asynchronous mode</b>. For more, please refer to <a class="el" href="md_introduction.html">introduction.md</a>.   </td></tr>
</table>
<p >The behaviour of function <b>arm_2d_rbg32_tile_copy_with_colour_keying</b> is illustrated in <b>Figure 4.6</b>. This function copies a given source tile to a specified region inside a target tile. During this process, the user can specify a colour as the masking colour. If the colour of the pixel read from the source tile is the masking colour, the copy operation for that pixel will be ignored. As a result, i.e. the pixel in the background will be used. This function is dedicated to all colour formats with the 32-bit pixel.</p>
<p ><b>NOTE</b>: Alpha channels are ignored even if they exist. If you want a version that takes alpha-channel into consideration, please check alpha-blending related APIs.</p>
<h1><a class="anchor" id="autotoc_md132"></a>
5 Reference</h1>
<ol type="1">
<li><a class="el" href="md_introduction.html">Introduction to Arm-2D</a> </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <script type="text/javascript">
        <!--
        writeFooter.call(this);
        //-->
      </script> 
    </li>
  </ul>
</div>
</body>
</html>
