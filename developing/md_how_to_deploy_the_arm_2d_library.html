<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Arm-2D: How to Deploy the Arm-2D Library {#deploy} &lt;!-- omit from toc --&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="footer.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="version.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../version.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 55px;">
  <td id="projectlogo" style="padding: 1.5em;"><img alt="Logo" src="arm.png"/></td>
  <td style="padding-left: 1em; padding-bottom: 1em;padding-top: 1em;">
   <div id="projectname">Arm-2D
   &#160;<span id="projectnumber"><script type="text/javascript">
     <!--
     writeHeader.call(this);
     writeVersionDropdown(this);
     //-->
    </script>
   </span>
   </div>
   <div id="projectbrief">2D Image Processing Library for Cortex-M Processors</div>
  </td>
  <!--END !PROJECT_NAME-->
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_how_to_deploy_the_arm_2d_library.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">How to Deploy the Arm-2D Library {#deploy}  </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >This document describes how to deploy the <b>Arm-2D</b> library to your existing MDK projects. If you are not familiar with <b>Arm-2D</b>, please start from the <b><a class="el" href="md__home_runner_work_Arm_2D_Arm_2D_README.html">README</a></b> first.</p>
<h2><a class="anchor" id="autotoc_md71"></a>
Table of Contents</h2>
<ul>
<li>1 How to get the Arm-2D</li>
<li>2 How to Deploy Arm-2D<ul>
<li>2.1 Deploy Using CMSIS-Pack in MDK</li>
<li>2.2 Deploy Using CMake</li>
<li>2.3 Deploy Using Makefile</li>
</ul>
</li>
<li>3 Helper Services and Extras<ul>
<li>3.1 Preparation</li>
<li>3.2 Add Display Adapter Service</li>
<li>3.3 Configure the Display Adapter Service</li>
<li>3.4 Implement the External Reference Timer</li>
<li>3.5 Verifying The Porting Result</li>
<li>3.6 Asynchronous Flushing Mode</li>
<li>3.7 Direct Mode (3FB Mode)</li>
</ul>
</li>
<li>4 Example Projects</li>
</ul>
<h1><a class="anchor" id="autotoc_md72"></a>
1 How to get the Arm-2D</h1>
<p >There are three methods to get Arm-2D:</p>
<ul>
<li><p class="startli">Cloning Arm-2D repository on Github using the following command line:</p>
<div class="fragment"><div class="line">git clone https://github.com/ARM-software/Arm-2D.git</div>
</div><!-- fragment --></li>
<li>Downloading Arm-2D CMSIS-Pack from the <a href="https://github.com/ARM-software/Arm-2D/releases">release page</a>.</li>
<li><p class="startli">Checking for Updates in pack-installer and installing the latest Arm-2D packs as shown in <b>Figure 1-1</b> and <b>Figure 1-2</b></p>
<p class="startli"><b>Figure 1-1 Check for Updates in Pack Installer</b></p>
</li>
</ul>
<div class="image">
<img src="HowToDeploy1_1.png" alt=""/>
</div>
    <p ><b>Figure 1-2 Install Arm-2D in Pack Installer</b></p>
<div class="image">
<img src="HowToDeploy1_2.png" alt=""/>
</div>
    <h1><a class="anchor" id="autotoc_md73"></a>
2 How to Deploy Arm-2D</h1>
<h2><a class="anchor" id="autotoc_md74"></a>
2.1 Deploy Using CMSIS-Pack in MDK</h2>
<ol type="1">
<li><p class="startli">Open the Run-Time Environment configuration dialog using menu "Project-&gt;Manage-&gt;Run-Time Environment" as shown in <b>Figure 2-6</b>.</p>
<p class="startli"><b>Figure 2-6 Open Run-Time Environment Dialog</b> <img src="HowToDeploy2_6.png" alt="" class="inline"/>    </p>
</li>
</ol>
<ol type="1">
<li><p class="startli">Expand <b>Acceleration</b> and select <b>Core</b>, <b>Alpha-Blending</b> and <b>Transform</b> under <b>Arm-2D</b> as shown below. Make sure you also select <b>CMSIS-CORE</b> and <b>CMSIS-DSP</b>.</p>
<p class="startli"><b>Figure 2-7 Select Arm-2D in RTE</b> <img src="HowToDeploy2_7.png" alt="" class="inline"/>    </p>
</li>
</ol>
<ol type="1">
<li><p class="startli">Enable <b>C11</b> and <b>GNU extension</b> support in C/C++(AC6) configurations:</p>
<p class="startli"><b>Figure 2-3 Enable "gnu11" in Arm Compiler 6</b></p>
</li>
</ol>
<div class="image">
<img src="HowToDeploy2_3.png" alt=""/>
<div class="caption">
image-20210323171224685</div></div>
    <ol type="1">
<li><p class="startli">Include the header file <code><a class="el" href="arm__2d_8h_source.html">arm_2d.h</a></code> in your source code where you want to use the library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;arm_2d.h&quot;</span></div>
</div><!-- fragment --></li>
<li><p class="startli">Initialize Arm-2D by calling function <code><a class="el" href="group__gKernel.html#gae417897e7d7186b294c0ff3468102276" title="initialise arm-2d">arm_2d_init()</a></code> :</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> system_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <a class="code hl_function" href="group__gKernel.html#gae417897e7d7186b294c0ff3468102276" title="initialise arm-2d">arm_2d_init</a>();</div>
<div class="line">   ...</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli">Expand Acceleration in the project view and open <code>arm_2d_cfg.h</code> as shown in <b>Figure 2-8</b>.</p>
<p class="startli"><b>Figure 2-8 Find arm_2d_cfg.h in the project view</b></p>
</li>
</ol>
<p ><img src="HowToDeploy2_8.png" alt="" class="inline"/>     <br  />
</p>
<p >Open the <b>Configuration Wizard</b> and check options available for Arm-2D</p>
<p ><b>Figure 2-9 Configuration Wizard for Arm-2D</b></p>
<div class="image">
<img src="HowToDeploy2_9.png" alt=""/>
<div class="caption">
ConfigurationWizardForArm-2D</div></div>
    <p ><b>NOTE</b>: If you want to support <b>CCCA8888</b> (i.e. <b>RGBA8888</b>), please selet the <code>Enable support for accessing individual colour channels</code>.</p>
<h2><a class="anchor" id="autotoc_md75"></a>
2.2 Deploy Using CMake</h2>
<p >It is easy to deploy arm-2d as a library using CMake; for details, please check the <a href="../CMakeLists.txt">CMakeLists.txt</a>.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
2.3 Deploy Using Makefile</h2>
<p >It is possible to deploy arm-2d using a Makefile. We suppose you are familiar with writing Makefile scripts and hence provide a <a href="../examples/[template][pc][vscode]/Makefile">Makefile</a> used on PC as a good example.</p>
<h1><a class="anchor" id="autotoc_md77"></a>
3 Helper Services and Extras</h1>
<p >Suppose you want to develop GUI applications directly with Arm-2D. In that case, it implies that you not only use Arm-2D APIs for the framebuffer-based low-level 2D image processing but also want to display the processed result on a screen. An ordinary GUI software stack will provide a dedicated service for connecting a target screen, and users must implement a driver or adapter between the hardware and the service. Such a service usually allows people to refresh the whole screen with a petite frame buffer called <b>Partial Frame Buffer (PFB)</b>. This feature is vital for resource-constrained embedded platforms. Arm-2D provide a similar feature through a helper service called the Display Adapter Service.</p>
<h2><a class="anchor" id="autotoc_md78"></a>
3.1 Preparation</h2>
<p >Before we start, we have to prepare a low-level flushing function called Disp0_DrawBitmap(). Its prototype is shown below:</p>
<div class="fragment"><div class="line">int32_t Disp0_DrawBitmap(int16_t x, </div>
<div class="line">                        int16_t y, </div>
<div class="line">                        int16_t width, </div>
<div class="line">                        int16_t height, </div>
<div class="line">                        <span class="keyword">const</span> uint8_t *bitmap);</div>
</div><!-- fragment --><p >Here, as shown in <b>Figure 3-1</b>:</p>
<ul>
<li><code>x</code>,<code>y</code> are the absolute coordinates in the target screen</li>
<li><code>width</code> and<code>height</code> describe the size of the rectangular target area</li>
<li><code>bitmap</code> points to a framebuffer which holds all pixels in a rectangular area with the given <code>width</code> and <code>height</code>.</li>
</ul>
<p ><b>Figure 3-1 The Scheme of the Low-Level Flushing Interface</b></p>
<p ><img src="./pictures/Disp0_DrawBitmap.png" alt="Disp0_DrawBitmap" style="zoom:70%;" class="inline"/></p>
<p >Suppose the display RAM of your LCD has been mapped into internal 4G memory space. An example of <code>Disp0_DrawBitmap()</code> might look like this:</p>
<div class="fragment"><div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment">  \fn          int32_t Disp0_DrawBitmap (uint32_t x, uint32_t y, uint32_t width, uint32_t height, const uint8_t *bitmap)</span></div>
<div class="line"><span class="comment">  \brief       Draw bitmap (bitmap from BMP file without header)</span></div>
<div class="line"><span class="comment">  \param[in]   x      Start x position in pixels (0 = left corner)</span></div>
<div class="line"><span class="comment">  \param[in]   y      Start y position in pixels (0 = upper corner)</span></div>
<div class="line"><span class="comment">  \param[in]   width  Bitmap width in pixels</span></div>
<div class="line"><span class="comment">  \param[in]   height Bitmap height in pixels</span></div>
<div class="line"><span class="comment">  \param[in]   bitmap Bitmap data</span></div>
<div class="line"><span class="comment">  \returns</span></div>
<div class="line"><span class="comment">   - \b  0: function succeeded</span></div>
<div class="line"><span class="comment">   - \b -1: function failed</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">int32_t Disp0_DrawBitmap (uint32_t x, uint32_t y, uint32_t width, uint32_t height, <span class="keyword">const</span> uint8_t *bitmap) </div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">volatile</span> uint16_t *phwDes = disp_ram + y * GLCD_WIDTH + x;</div>
<div class="line">    <span class="keyword">const</span> uint16_t *phwSrc = (<span class="keyword">const</span> uint16_t *)bitmap;</div>
<div class="line">    <span class="keywordflow">for</span> (int_fast16_t i = 0; i &lt; height; i++) {</div>
<div class="line">        memcpy ((uint16_t *)phwDes, phwSrc, width * 2);</div>
<div class="line">        phwSrc += width;</div>
<div class="line">        phwDes += GLCD_WIDTH;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Here, <code>disp_ram</code> points to the memory space reserved for the LCD display RAM.</p>
<p ><b>IMPORTANT</b>:</p>
<ol type="1">
<li>When exiting the <code>Disp0_DrawBitmap()</code>, Arm-2D assumes that the target frame buffer has already been flushed to the target screen.</li>
<li><b>Please verify the <code>Disp0_DrawBitmap()</code> functional correctness without Arm-2d before moving to the next steps.</b></li>
</ol>
<h2><a class="anchor" id="autotoc_md79"></a>
3.2 Add Display Adapter Service</h2>
<p >Deploying Display Adatper service in MDK is simple:</p>
<ol type="1">
<li>Open RTE dialog (as shown in <b>Figure 3-2</b>)</li>
<li>Expand <code>Acceleration::Arm-2D Helper</code></li>
<li>Select the <b>PFB</b> and increase the number of <b>Display Adapter</b> to <code>1</code>. <b>NOTE</b>: If you have multiple screens, please set the number accordingly.</li>
<li>If you see any warning message in yellow, please click the Resolve button. The warning should disappear.</li>
<li>Click <b>OK</b> button to close the RTE dialog.</li>
</ol>
<p ><b>Figure 3-2 Selecting Display Adapter Service in RTE</b></p>
<div class="image">
<img src="DisplayAdapter.png" alt=""/>
<div class="caption">
AddDisplayAdapter</div></div>
    <p >After that, you will see two files, i.e. <code>arm_2d_disp_adapter_0.c</code> and <code>arm_2d_disp_adapter_0.h</code> have been added to the project manager under the <b>Acceleration</b> group.</p>
<p ><b>IMPORTANT</b>: unless necessary, please do <b>NOT</b> modify the content of the <code>arm_2d_disp_adapter_0.c</code>, as new versions of Arm-2D often introduce new features to the Display Adatper Service, as long as you haven't modified anything in the <code>arm_2d_disp_adapter_0.c</code>, updating to the latest version would be an easy task nothing more than right-clicking the file in the project manager and updating to the latest version in the pop-up menu.</p>
<p ><b>You have to initalise the Display Adapter service before using it</b>.</p>
<p >Include <code>arm_2d_disp_adapters.h</code> in your c source code and add the following code to the <code>main()</code> function:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;arm_2d_helper.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;arm_2d_disp_adapters.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;arm_2d_scenes.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef LCD_TARGET_FPS</span></div>
<div class="line"><span class="preprocessor">#   define LCD_TARGET_FPS       30</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>) </div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    arm_irq_safe {</div>
<div class="line">        <a class="code hl_function" href="group__gKernel.html#gae417897e7d7186b294c0ff3468102276" title="initialise arm-2d">arm_2d_init</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* initialize the display adapter 0 service */</span></div>
<div class="line">    disp_adapter0_init();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (1) {</div>
<div class="line">        <span class="comment">/* lock framerate */</span></div>
<div class="line">        disp_adapter0_task(LCD_TARGET_FPS);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >Or the thread function if you want to run Arm-2d in an RTOS environment:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;arm_2d_helper.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;arm_2d_disp_adapters.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;arm_2d_scenes.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef LCD_TARGET_FPS</span></div>
<div class="line"><span class="preprocessor">#   define LCD_TARGET_FPS       30</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">__NO_RETURN</div>
<div class="line"><span class="keywordtype">void</span> app_2d_main_thread (<span class="keywordtype">void</span> *argument) </div>
<div class="line">{</div>
<div class="line">    arm_irq_safe {</div>
<div class="line">        <a class="code hl_function" href="group__gKernel.html#gae417897e7d7186b294c0ff3468102276" title="initialise arm-2d">arm_2d_init</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* initialize the display adapter 0 service */</span></div>
<div class="line">    disp_adapter0_init();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span>(1) {<span class="comment"></span></div>
<div class="line"><span class="comment">        //! retrieve the number of system ticks</span></div>
<div class="line"><span class="comment"></span>        uint32_t wTick = osKernelGetTickCount();</div>
<div class="line">      </div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">            <a class="code hl_enumeration" href="group__gKernel.html#ga373f79d09c0d15653ca46ea08e0377fc" title="finite-state-machine status return (Compatible with arm_status, minimal integer: int8_t)">arm_fsm_rt_t</a> tResult = disp_adapter0_task();</div>
<div class="line">            <span class="keywordflow">if</span> (tResult == <a class="code hl_enumvalue" href="group__gKernel.html#gga373f79d09c0d15653ca46ea08e0377fcacf7b5f9e66c44d332ea46d05860d78d1" title="fsm complete">arm_fsm_rt_cpl</a> || tResult == <a class="code hl_enumvalue" href="group__gKernel.html#gga27a24a896295488772e6d847c790fd1caf2c830c9cbb2fe95aecbdf5538e5deb8" title="frame is skipped">ARM_2D_RT_FRAME_SKIPPED</a>) {</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">while</span>(1);</div>
<div class="line">        <span class="comment"></span></div>
<div class="line"><span class="comment">        //! lock frame rate</span></div>
<div class="line"><span class="comment"></span>        osDelayUntil(wTick + (1000 / LCD_TARGET_FPS));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//osThreadExit();</span></div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p >&zwj;[!NOTE]</p>
<ol type="1">
<li>The <code>disp_adapter0_task()</code> returns <code>arm_fsm_rt_cpl</code> when finishing drawing a frame and returns <code>ARM_2D_RT_FRAME_SKIPPED</code> when there is nothing to update. </li>
</ol>
</blockquote>
<h2><a class="anchor" id="autotoc_md80"></a>
3.3 Configure the Display Adapter Service</h2>
<p >You should configure the Display Adapter service before using it. All the configurations of a Display Adapter service are stored in the corresponding header file, e.g. <code>arm_2d_disp_adapter_0.h</code>. In MDK, all configuration work can be done through the GUI wizard, as shown in <b>Figure 3-3</b>.</p>
<p ><b>Figure 3-3 Configure the Display Adapter Using the Wizard</b></p>
<div class="image">
<img src="ConfigureDisplayAdapter.png" alt=""/>
<div class="caption">
ConfigureTheDisplayAdapter</div></div>
    <p >There are many options available in the list, and we only explain those important and commonly used ones here:</p>
<p ><b>Table 3-1 The Important and Commonly Used Options of the Display Adapter Service</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Options   </th><th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Default   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Select the screen colour depth   </td><td class="markdownTableBodyNone">8bits/16bits/32bits   </td><td class="markdownTableBodyNone">16bits   </td><td class="markdownTableBodyNone">The number of bits per pixel. For monochrome LCD and e-ink LCD, please select the 8bits.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Width of the screen   </td><td class="markdownTableBodyNone">8...32767   </td><td class="markdownTableBodyNone">320   </td><td class="markdownTableBodyNone">The width of the target screen    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Height of the screen   </td><td class="markdownTableBodyNone">8...32767   </td><td class="markdownTableBodyNone">240   </td><td class="markdownTableBodyNone">The height of the target screen    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Width of the PFB block   </td><td class="markdownTableBodyNone">1...32767   </td><td class="markdownTableBodyNone">320   </td><td class="markdownTableBodyNone">The width of a partial frame buffer (PFB). If possible, please use the screen width here.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Height of the PFB block   </td><td class="markdownTableBodyNone">1...32767   </td><td class="markdownTableBodyNone">240   </td><td class="markdownTableBodyNone">The height of a partial frame buffer (PFB). It is recommended to start from 1/10 of the height of the screen. If possible, do not use a value smaller than 8.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Width Alignment of generated PFBs   </td><td class="markdownTableBodyNone">1/2/4...128 pixels   </td><td class="markdownTableBodyNone">1 pixel   </td><td class="markdownTableBodyNone">The horizontal pixel alignment of the PFBs sending to the <code>DispN_DrawBitmap()</code> for flushing. It is important for LCDs that have certain pixel alignment requirements. For example, 8 pixel alignment for monochrome LCDs and 4 pixel alignment for e-inks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Height Alignment of generated PFBs   </td><td class="markdownTableBodyNone">1/2/4...128 pixels   </td><td class="markdownTableBodyNone">1 pixel   </td><td class="markdownTableBodyNone">The vertical pixel alignment of the PFBs sending to the <code>DispN_DrawBitmap()</code> for flushing. It is important for LCDs that have certain pixel alignment requirements. For example, 8 pixel alignment for some 12864 monochrome LCDs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PFB Block Count   </td><td class="markdownTableBodyNone">1...32767   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">The number of PFB blocks in the pool. Please set it to <code>2</code> or more when using Asynchornose flushing mode; otherwise, keep it as <code>1</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Number of iterations   </td><td class="markdownTableBodyNone">0...32767   </td><td class="markdownTableBodyNone">30   </td><td class="markdownTableBodyNone">Calculate the real-time FPS for every specified number of frames. Set it to <code>0</code> to disable the real-time FPS calculation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FPS Calculation Mode   </td><td class="markdownTableBodyNone">Render-Only FPS/Real FPS   </td><td class="markdownTableBodyNone">Render-Only FPS   </td><td class="markdownTableBodyNone"><b>Render-Only FPS</b>: record the time used by the renderer and use it to calculate the FPS without taking LCD latency into consideration. <br  />
<b>Real FPS</b>: calculate the real FPS people actually see on the screen.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Swap the high and low bytes   </td><td class="markdownTableBodyNone">Select/Unselect   </td><td class="markdownTableBodyNone">Unselect   </td><td class="markdownTableBodyNone">Some RGB565 LCDs require swapping the high and the low bytes for each pixel. Please <b>ONLY</b> enable this option when there is no hardware solution to swap the high and low bytes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Enable the helper service for Asynchronous Flushing   </td><td class="markdownTableBodyNone">Select/Unselect   </td><td class="markdownTableBodyNone">Unselect   </td><td class="markdownTableBodyNone">By selecting this option, a dedicated helper service will be provided for asynchronous flushing mode. For more, please read the guidance in the header file.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Disable the default Scene   </td><td class="markdownTableBodyNone">Select/Unselect   </td><td class="markdownTableBodyNone">Unselect   </td><td class="markdownTableBodyNone">A Display Adapter brings a default scene for indicating successful porting. You can disable it by selecting this option.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Disable the navigation layer   </td><td class="markdownTableBodyNone">Select/Unselect   </td><td class="markdownTableBodyNone">Unselect   </td><td class="markdownTableBodyNone">A Display Adapter uses the navigation layer (which is floating above the content created by users) to show real-time FPS and version info. You should disable it before the product releasing or disable it to add your own navigation layer.   </td></tr>
</table>
<p ><b>NOTE</b>:</p>
<ul>
<li>If the target device cannot afford the full frame buffer, please set the PFB size (i.e. width and/or height) to a smaller value. <b>We recommend you start with a 1/10 full frame buffer</b>, as it actually isn't 10x slower than using a full frame buffer.</li>
<li>For <b>monochrome LCDs</b>, you should use 8-bit colour depth and pack every 8 pixels into one byte in the <code>Disp0_DrawBitmap()</code>. Don't forget to set the PFB alignment to 8 horizontally or vertically depending on the monochrome LCD pixel layout.</li>
<li>For <b>2-bit e-ink LCDs</b>, you should use 8-bit colour depth and pack every 4 pixels into one byte in the <code>Disp0_DrawBitmap()</code>. Don't forget to set the PFB alignment to 4 horizontally or vertically depending on the e-ink LCD pixel layout.</li>
<li>For <b>4-bit e-ink LCDs</b>, you should use 8-bit colour depth and pack every 2 pixels into one byte in the <code>Disp0_DrawBitmap()</code>. Don't forget to set the PFB alignment to 2 horizontally or vertically depending on the e-ink LCD pixel layout.</li>
<li>Please make sure the stack size is no less than 3K Bytes.</li>
</ul>
<h2><a class="anchor" id="autotoc_md81"></a>
3.4 Implement the External Reference Timer</h2>
<p >Arm-2D helper service relies on an external reference timer which we should implement:</p>
<p ><b>Table 3-2 The Interface for Accessing the External Timer</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Interface Prototype   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int64_t <a class="el" href="group__gHelper.html#gaf92c1f5d41f75d4a8514ab79c34f1185" title="get the current system stamp from the reference clock">arm_2d_helper_get_system_timestamp(void)</a>   </td><td class="markdownTableBodyNone">a function that returns the number of ticks (timestamp) of the reference timer since reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint32_t <a class="el" href="group__gHelper.html#gace60efc807106e1526fcc9f673f19b12" title="get the reference clock frequency">arm_2d_helper_get_reference_clock_frequency(void)</a>   </td><td class="markdownTableBodyNone">the frequency of the reference timer.   </td></tr>
</table>
<p ><b>We highly recommand you to install perf_counter from Pack-Installer, <a href="https://www.keil.arm.com/packs/">Keil Website</a> or <a href="https://github.com/GorgonMeducer/perf_counter/releases">its Github repo</a> to simplify this process.</b> You have to initialize the perf_counter before using Arm-2D. For more, please read the <a href="https://github.com/GorgonMeducer/perf_counter/blob/main/README.md">guidance here</a>.</p>
<h2><a class="anchor" id="autotoc_md82"></a>
3.5 Verifying The Porting Result</h2>
<p >After finished steps above, if everything goes well, you should see a screen as shown in <b>Figure 3-4</b>. If the colour doesn't look right and the LCD uses RGB565, try to swap the high and low bytes for each pixel. <br  />
</p>
<p ><b>Figure 3-4 The Look of The Default Scene In A Successful Porting</b></p>
<div class="image">
<img src="DispAdapterDefaultScene.gif" alt=""/>
</div>
    <p >If you encounter any problems, please feel free to raise an issue.</p>
<p >Enjoy.</p>
<h2><a class="anchor" id="autotoc_md83"></a>
3.6 Asynchronous Flushing Mode</h2>
<p >Different from the method described in <b>section 3.1</b> that lets the CPU flush the LCD directly, it is possible to use DMA (or peripherals with similar capability) to offload the processor - we call it <b>Asynchronous Flushing</b> mode, and the method described before is often referred as <b>Synchronous Flushing</b> mode.</p>
<p >To enable Asynchronous Flushing:</p>
<ol type="1">
<li>Select <code>Enable the helper service for Asynchronous Flushing</code> in the Display Adapter configuration wizard, or equivalently define the macro <code>__DISPn_CFG_ENABLE_ASYNC_FLUSHING__</code> as <code>1</code> (here <b>n</b> represents the display adapter index number).</li>
<li>Implement the user defined function called <code>__disp_adapterN_request_async_flushing()</code>(here <b>N</b> represents the display adapter index number). The function prototype is shown as below: <div class="fragment"><div class="line"><span class="comment">/*!</span></div>
<div class="line"><span class="comment"> * \brief It is an user implemented function that request an LCD flushing in </span></div>
<div class="line"><span class="comment"> *        asynchronous manner. </span></div>
<div class="line"><span class="comment"> * \note User MUST implement this function when </span></div>
<div class="line"><span class="comment"> *       __DISP0_CFG_ENABLE_ASYNC_FLUSHING__ is set to &#39;1&#39;</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * \param[in] pTarget an user specified object address</span></div>
<div class="line"><span class="comment"> * \param[in] bIsNewFrame whether this flushing request is the first iteration </span></div>
<div class="line"><span class="comment"> *            of a new frame.</span></div>
<div class="line"><span class="comment"> * \param[in] iX the x coordinate of a flushing window in the target screen</span></div>
<div class="line"><span class="comment"> * \param[in] iY the y coordinate of a flushing window in the target screen</span></div>
<div class="line"><span class="comment"> * \param[in] iWidth the width of a flushing window</span></div>
<div class="line"><span class="comment"> * \param[in] iHeight the height of a flushing window</span></div>
<div class="line"><span class="comment"> * \param[in] pBuffer the frame buffer address</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> __disp_adapter0_request_async_flushing( </div>
<div class="line">    <span class="keywordtype">void</span> *pTarget,</div>
<div class="line">    <span class="keywordtype">bool</span> bIsNewFrame,</div>
<div class="line">    int16_t iX, </div>
<div class="line">    int16_t iY,</div>
<div class="line">    int16_t iWidth,</div>
<div class="line">    int16_t iHeight,</div>
<div class="line">    <span class="keyword">const</span> COLOUR_INT *pBuffer);</div>
</div><!-- fragment --> ​ We use this function to send a DMA transaction request, and enable interrupt generation for this transaction.</li>
<li>In the DMA transaction complete interrupt service routine, call function <code>disp_adapterN_insert_async_flushing_complete_event_handler()</code> to report the event to the display adapter service (here <b>N</b> represents the display adapter index number).</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">/*!</span></div>
<div class="line"><span class="comment"> * \brief the handler for the asynchronous flushing complete event.</span></div>
<div class="line"><span class="comment"> * \note When __DISP0_CFG_ENABLE_ASYNC_FLUSHING__ is set to &#39;1&#39;, user </span></div>
<div class="line"><span class="comment"> *       MUST call this function to notify the PFB helper that the previous</span></div>
<div class="line"><span class="comment"> *       asynchronous flushing is complete. </span></div>
<div class="line"><span class="comment"> * \note When people using DMA+ISR to offload CPU, this fucntion is called in </span></div>
<div class="line"><span class="comment"> *       the DMA transfer complete ISR.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">extern</span></div>
<div class="line"><span class="keywordtype">void</span> disp_adapter0_insert_async_flushing_complete_event_handler(<span class="keywordtype">void</span>);</div>
</div><!-- fragment --><blockquote class="doxtable">
<p >&zwj; NOTE: If the device connects LCD via SPI, when using DMA for transaction, please handle the CS signal properly. Usually, we set the CS to low before sending the DMA transaction request in <code>__disp_adapterN_request_async_flushing()</code> and raise CS to high in the DMA transaction complete interrupt service routine (ISR). </p>
</blockquote>
<ol type="1">
<li>In <b>Asynchronous Flushing</b> mode, it is better to increase the<code>PFB Block Count</code> to <code>2</code> (or even <code>3</code>) in the configuration wizard, or equivalently define the macro <code>__DISPn_CFG_PFB_HEAP_SIZE__</code> as <code>2</code> (or even <code>3</code>), here <b>n</b> represents the display adapter index number. A typical configuration is shown in <b>Figure 3-5</b>.</li>
</ol>
<p ><b>Figure 3-5 A Typical Configuration for Enabling Asynchronous Flushing Mode in the Wizard.</b></p>
<div class="image">
<img src="EnableAsynchronosFlushingInWizard.png" alt=""/>
<div class="caption">
image-20231120152652919</div></div>
    <p >It is worth to note that in Asynchronous Flushing mode, because the LCD Flushing parallels with the new FPB drawing:</p>
<ul>
<li>If the <b>actual LCD Latency</b> is equals to or smaller than the PFB drawing time, the <b>displayed LCD Latency</b> is <code>0ms</code>, otherwise</li>
<li>The <b>displayed LCD latency</b> is equals to <b>the Actual LCD Latency minus the PFB Drawing time</b>, and usually very small.</li>
</ul>
<h2><a class="anchor" id="autotoc_md84"></a>
3.7 Direct Mode (3FB Mode)</h2>
<p >To avoid the tearing effects, some devices provide a dedicated LCD controller peripheral, often known as <b>LTDC</b>. The LCD controller maps a <b>FULL framebuffer</b> as the display RAM and copies the content in the display RAM to the LCD in a fixed frequency. During this period, there is a time-window indicated by a signal often known as <b>TE</b> or <b>VSYNC</b>, as long as we can finish flushing the LCD in this time-window, the tearing problem can be avoided.</p>
<p >Direct mode is such a mode that exchanges the FULL framebuffer as the display RAM on VSYNC or TE events. Arm-2D supports the Direct Mode through a dedicated helper service.</p>
<p >To enable the 3FB helper service:</p>
<ol type="1">
<li>Select <code>Enable the helper service for 3FB (LCD Direct Mode)</code> in the Display Adapter Configuration Wizard, or equivalently define the macro <code>__DISPn_CFG_ENABLE_3FB_HELPER_SERVICE__</code> as <code>1</code> (here <b>n</b> represents the display adapter index number).</li>
<li>Implement the following <code>uintptr_t</code> variables to indicate the address of three <b>FULL-Framebuffer</b>:</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">extern</span> uintptr_t __DISP_ADAPTERn_3FB_FB0_ADDRESS__;</div>
<div class="line"><span class="keyword">extern</span> uintptr_t __DISP_ADAPTERn_3FB_FB1_ADDRESS__;</div>
<div class="line"><span class="keyword">extern</span> uintptr_t __DISP_ADAPTERn_3FB_FB2_ADDRESS__;</div>
</div><!-- fragment --><blockquote class="doxtable">
<p >&zwj; NOTE: <br  />
</p>
<ol type="1">
<li>Here <b>n</b> represents the display adapter index number.</li>
<li>The three variables should be initialized with the proper value before initialization of the corresponding display adapter service. </li>
</ol>
</blockquote>
<ol type="1">
<li>In the <b>VSYN</b> or <b>TE</b> event handler, call function <code>disp_adapterN_3fb_get_flush_pointer()</code> to get a framebuffer pointer and use it to update the LTDC. (Here <b>N</b> represent the display adapter index number)</li>
</ol>
<p >In fact, the Direct Mode can be used together with the Asynchronous Flushing mode. If the two modes are enabled at the same time, users have to implement the following functions:</p>
<div class="fragment"><div class="line"><span class="comment">/*!</span></div>
<div class="line"><span class="comment"> * \brief An user implemented interface for DMA memory-to-memory copy.</span></div>
<div class="line"><span class="comment"> *        You should implement an ISR for copy-complete event and call</span></div>
<div class="line"><span class="comment"> *        disp_adapterN_insert_dma_copy_complete_event_handler() or</span></div>
<div class="line"><span class="comment"> *        arm_2d_helper_3fb_report_dma_copy_complete() to notify the </span></div>
<div class="line"><span class="comment"> *        3FB (direct mode) helper service.</span></div>
<div class="line"><span class="comment"> * </span></div>
<div class="line"><span class="comment"> * \param[in] ptThis the helper service control block</span></div>
<div class="line"><span class="comment"> * \param[in] pObj the address of the user object</span></div>
<div class="line"><span class="comment"> * \param[in] pnSource the source address of the memory block</span></div>
<div class="line"><span class="comment"> * \param[in] pnTarget the target address</span></div>
<div class="line"><span class="comment"> * \param[in] nDataItemCount the number of date items</span></div>
<div class="line"><span class="comment"> * \param[in] chDataItemSize the size of each data item </span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">extern</span></div>
<div class="line"><span class="keywordtype">void</span> __disp_adapterN_request_dma_copy(  <a class="code hl_struct" href="group__gHelper.html#structarm__2d__helper__3fb__t" title="the control block of the 3FB (direct mode) service">arm_2d_helper_3fb_t</a> *ptThis,</div>
<div class="line">                                        <span class="keywordtype">void</span> *pObj,</div>
<div class="line">                                        uintptr_t pnSource,</div>
<div class="line">                                        uintptr_t pnTarget,</div>
<div class="line">                                        uint32_t nDataItemCount,</div>
<div class="line">                                        uint_fast8_t chDataItemSize);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*!</span></div>
<div class="line"><span class="comment"> * \brief An user implemented interface for 2D-Copy.</span></div>
<div class="line"><span class="comment"> * \param[in] pnSource the source image address</span></div>
<div class="line"><span class="comment"> * \param[in] wSourceStride the stride of the source image</span></div>
<div class="line"><span class="comment"> * \param[in] pnTarget the address in the target framebuffer</span></div>
<div class="line"><span class="comment"> * \param[in] wTargetStride the stride of the target framebuffer</span></div>
<div class="line"><span class="comment"> * \param[in] iWidth the safe width of the source image</span></div>
<div class="line"><span class="comment"> * \param[in] iHeight the safe height of the source image</span></div>
<div class="line"><span class="comment"> * \retval true the 2D copy is complete when leaving this function</span></div>
<div class="line"><span class="comment"> * \retval false An async 2D copy request is sent to the DMA</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * \note if false is replied, you have to call </span></div>
<div class="line"><span class="comment"> *       disp_adapter0_insert_2d_copy_complete_event_handler() to report</span></div>
<div class="line"><span class="comment"> *       the completion of the 2d-copy. </span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> __disp_adapterN_request_2d_copy(   <a class="code hl_struct" href="group__gHelper.html#structarm__2d__helper__3fb__t" title="the control block of the 3FB (direct mode) service">arm_2d_helper_3fb_t</a> *ptThis,</div>
<div class="line">                                        <span class="keywordtype">void</span> *pObj,</div>
<div class="line">                                        uintptr_t pnSource,</div>
<div class="line">                                        uint32_t wSourceStride,</div>
<div class="line">                                        uintptr_t pnTarget,</div>
<div class="line">                                        uint32_t wTargetStride,</div>
<div class="line">                                        int16_t iWidth,</div>
<div class="line">                                        int16_t iHeight,</div>
<div class="line">                                        uint_fast8_t chBytePerPixel );</div>
</div><!-- fragment --><p >In DMA transaction complete event handler, please call the corresponding function to report the completion of the transaction:</p>
<div class="fragment"><div class="line"><span class="comment">/*!</span></div>
<div class="line"><span class="comment"> * \brief the handler for the 2d copy complete event.</span></div>
<div class="line"><span class="comment"> * \note When both __DISPn_CFG_ENABLE_ASYNC_FLUSHING__ and </span></div>
<div class="line"><span class="comment"> *       __DISPn_CFG_ENABLE_3FB_HELPER_SERVICE__ is set to &#39;1&#39;, user </span></div>
<div class="line"><span class="comment"> *       MUST call this function to notify the PFB helper that the previous</span></div>
<div class="line"><span class="comment"> *       asynchronouse 2d copy is complete. </span></div>
<div class="line"><span class="comment"> * \note When people using DMA+ISR to offload CPU, this fucntion is called in </span></div>
<div class="line"><span class="comment"> *       the DMA transfer complete ISR.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">extern</span></div>
<div class="line"><span class="keywordtype">void</span> disp_adapterN_insert_2d_copy_complete_event_handler(<span class="keywordtype">void</span>);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*!</span></div>
<div class="line"><span class="comment"> * \brief the handler for the dma copy complete event.</span></div>
<div class="line"><span class="comment"> * \note When both __DISPn_CFG_ENABLE_ASYNC_FLUSHING__ and </span></div>
<div class="line"><span class="comment"> *       __DISPn_CFG_ENABLE_3FB_HELPER_SERVICE__ is set to &#39;1&#39;, user </span></div>
<div class="line"><span class="comment"> *       MUST call this function to notify the PFB helper that the previous</span></div>
<div class="line"><span class="comment"> *       dma copy is complete. </span></div>
<div class="line"><span class="comment"> * \note When people using DMA+ISR to offload CPU, this fucntion is called in </span></div>
<div class="line"><span class="comment"> *       the DMA transfer complete ISR.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">extern</span></div>
<div class="line"><span class="keywordtype">void</span> disp_adapterN_insert_dma_copy_complete_event_handler(<span class="keywordtype">void</span>);</div>
</div><!-- fragment --><blockquote class="doxtable">
<p >&zwj;NOTE: Here, <b>N</b> and <b>n</b> represents the display adapter index number. </p>
</blockquote>
<p >When using 3FB mode, if the CPU can produce more frames than the display devices can handle, i.e. the CPU drawing framerate is higher than the LCD framerate, some frames will be overridden due to the overrun. We can introduce a simple LCD sync-up scheme to solve this issue.</p>
<p >Suppose we have an LCD Vsync event handler <code>lcd_vsync_event_handler()</code> that will be triggered periodically by the LCD controller, and we have an API <code>lcd_update_framebuffer()</code> to update the Display Framebuffer used by the LCD controller. Then, it is easy to write the following code to use the 3FB mode:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> lcd_vsync_event_handler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> * pFrameBuffer = disp_adapter0_3fb_get_flush_pointer();</div>
<div class="line">    lcd_udpate_framebuffer(pFrameBuffer);</div>
<div class="line">}</div>
</div><!-- fragment --><p >To establish a sync-up mechanism, we need a flag like <code>s_bRenderedCPL</code>, and we can create a function to poll this flag as shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> s_bRenderedCPL = <span class="keyword">true</span>; <span class="comment">/* it is important to initialize this flag as true */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> lcd_is_previous_frame_rendered(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> bResult = <span class="keyword">false</span>;</div>
<div class="line">    arm_irq_safe {</div>
<div class="line">        <span class="keywordflow">if</span> (s_bRenderedCPL) {</div>
<div class="line">            s_bRenderedCPL = <span class="keyword">false</span>;</div>
<div class="line">            bResult = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> bResult;</div>
<div class="line">}</div>
</div><!-- fragment --><p >After that, we have to update the flag <code>s_bRenderedCPL</code> in the VSync event handler:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> lcd_vsync_event_handler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> * pFrameBuffer = disp_adapter0_3fb_get_flush_pointer();</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> *s_pLastFB = NULL;</div>
<div class="line">    lcd_udpate_framebuffer(pFrameBuffer);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (s_bLastFB != pFrameBuffer) {</div>
<div class="line">        s_bRenderedCPL = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    s_bLastFB = pFrameBuffer;</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p >&zwj;[!NOTE]</p>
<p >Only when the Framebuffer pointer is different from the last one, we consider this as "last frame is rendered"; hence, update the flag <code>s_bRenderedCPL</code> to <code>true</code>. </p>
</blockquote>
<p>Now, the API <code>lcd_is_previous_frame_rendered</code> can tell us whether the previous frame is rendered or not. We should pass this information to display adapter service via a dedicated <b>Low-Level-Sync-Up</b> event handler. To register such an event handler, we need help from API <code><a class="el" href="group__gHelper.html#ga7f397129da5a5d78a7dd6325ab3405ef" title="update PFB dependency (event handlers)">arm_2d_helper_pfb_update_dependency()</a></code> as shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">bool</span> lcd_is_previous_frame_rendered(<span class="keywordtype">void</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> __lcd_sync_handler(<span class="keywordtype">void</span> *pTarget)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> lcd_is_previous_frame_rendered();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    arm_irq_safe {</div>
<div class="line">        <a class="code hl_function" href="group__gKernel.html#gae417897e7d7186b294c0ff3468102276" title="initialise arm-2d">arm_2d_init</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    disp_adapter0_init();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* register a low level sync-up handler to wait LCD finish rendering the previous frame */</span></div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">        <a class="code hl_struct" href="group__gHelper.html#structarm__2d__helper__pfb__dependency__t" title="The PFB Helper Service Dependency.">arm_2d_helper_pfb_dependency_t</a> tDependency = {</div>
<div class="line">            .<a class="code hl_variable" href="group__gHelper.html#a0ed423f1f6490f8cc89abd55f886f4cd">evtOnLowLevelSyncUp</a> = {</div>
<div class="line">                .<a class="code hl_variable" href="group__gKernel.html#a276d348c59950c0663e28adfc4829c99" title="event handler">fnHandler</a> = &amp;__lcd_sync_handler,</div>
<div class="line">            },</div>
<div class="line">        };</div>
<div class="line">        <a class="code hl_function" href="group__gHelper.html#ga7f397129da5a5d78a7dd6325ab3405ef" title="update PFB dependency (event handlers)">arm_2d_helper_pfb_update_dependency</a>(&amp;DISP0_ADAPTER.use_as__arm_2d_helper_pfb_t, </div>
<div class="line">                                            <a class="code hl_enumvalue" href="group__gHelper.html#ggad1df9dc2600f2dda7e99d31c00fd73e0ad7df2fe2d2065398cf935e34b6afedeb" title="On Low Level Sync-up Event.">ARM_2D_PFB_DEPEND_ON_LOW_LEVEL_SYNC_UP</a>,</div>
<div class="line">                                            &amp;tDependency);</div>
<div class="line">    } <span class="keywordflow">while</span>(0);</div>
<div class="line">    </div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">while</span>(1) {</div>
<div class="line">        disp_adapter0_task();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >The method mentioned above won't pause the thread if the LCD hasn't finished rendering the previous frame. instead, the <code>disp_adapterN_task()</code> will return <code>arm_fsm_rt_async</code> to indicate this status. You can ignore it, of course. Or you can use a semaphore to hang the thread in an RTOS environment. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> uintptr_t s_pLCDSem = NULL;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> set_lcd_cpl_sem(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="group__gHelper.html#gace219d9de63ad938b960ecc16ba95972" title="set a semaphore">arm_2d_port_set_semaphore</a>(s_pLCDSem);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    arm_irq_safe {</div>
<div class="line">        <a class="code hl_function" href="group__gKernel.html#gae417897e7d7186b294c0ff3468102276" title="initialise arm-2d">arm_2d_init</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    disp_adapter0_init();</div>
<div class="line">  </div>
<div class="line">    s_pLCDSem = <a class="code hl_function" href="group__gHelper.html#ga4d28a193f7ebb8b6381d22314106a113" title="get a new semaphore from host RTOS">arm_2d_port_new_semaphore</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* register a low level sync-up handler to wait LCD finish rendering the previous frame */</span></div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">        <a class="code hl_struct" href="group__gHelper.html#structarm__2d__helper__pfb__dependency__t" title="The PFB Helper Service Dependency.">arm_2d_helper_pfb_dependency_t</a> tDependency = {</div>
<div class="line">            .<a class="code hl_variable" href="group__gHelper.html#a0ed423f1f6490f8cc89abd55f886f4cd">evtOnLowLevelSyncUp</a> = {</div>
<div class="line">                .<a class="code hl_variable" href="group__gKernel.html#a276d348c59950c0663e28adfc4829c99" title="event handler">fnHandler</a> = &amp;__lcd_sync_handler,</div>
<div class="line">            },</div>
<div class="line">        };</div>
<div class="line">        <a class="code hl_function" href="group__gHelper.html#ga7f397129da5a5d78a7dd6325ab3405ef" title="update PFB dependency (event handlers)">arm_2d_helper_pfb_update_dependency</a>(&amp;DISP0_ADAPTER.use_as__arm_2d_helper_pfb_t, </div>
<div class="line">                                            <a class="code hl_enumvalue" href="group__gHelper.html#ggad1df9dc2600f2dda7e99d31c00fd73e0ad7df2fe2d2065398cf935e34b6afedeb" title="On Low Level Sync-up Event.">ARM_2D_PFB_DEPEND_ON_LOW_LEVEL_SYNC_UP</a>,</div>
<div class="line">                                            &amp;tDependency);</div>
<div class="line">    } <span class="keywordflow">while</span>(0);</div>
<div class="line">    </div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">while</span>(1) {</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="group__gKernel.html#gga373f79d09c0d15653ca46ea08e0377fca6904301c000a8bd3f1f13b557d18679b" title="fsm work asynchronously, please check it later.">arm_fsm_rt_async</a> == disp_adapter0_task()) {</div>
<div class="line">            <a class="code hl_function" href="group__gHelper.html#ga4ef26fee6266642ad57af1d1318aad9b" title="wait for a semaphore">arm_2d_port_wait_for_semaphore</a>(s_pLCDSem);   <span class="comment">/* hang the thread up */</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >And in the <code>lcd_vsync_event_handler</code>, we should call the function <code>set_lcd_cpl_sem()</code> as shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> set_lcd_cpl_sem(<span class="keywordtype">void</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> lcd_vsync_event_handler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> * pFrameBuffer = disp_adapter0_3fb_get_flush_pointer();</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> *s_pLastFB = NULL;</div>
<div class="line">    lcd_udpate_framebuffer(pFrameBuffer);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (s_bLastFB != pFrameBuffer) {</div>
<div class="line">        s_bRenderedCPL = <span class="keyword">true</span>;</div>
<div class="line">        set_lcd_cpl_sem();         <span class="comment">/* set the semaphore to wake the thread up */</span></div>
<div class="line">    }</div>
<div class="line">    s_bLastFB = pFrameBuffer;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md85"></a>
4 Example Projects</h1>
<p ><b>Table 3-1 Summary</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Projects   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Folder   </th><th class="markdownTableHeadNone">Note    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">[template][bare-metal]   </td><td class="markdownTableBodyNone">It is a project template for the bare-metal environment.   </td><td class="markdownTableBodyNone">examples/[template][bare-metal]   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">[template][cmsis-rtos2]   </td><td class="markdownTableBodyNone">It is a project template for the RTOS environment, which use CMSIS-RTOS2 as an example to show how Arm-2D can work with an RTOS.   </td><td class="markdownTableBodyNone">examples/[template][cmsis-rtos2]   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">[template][pc][vscode]   </td><td class="markdownTableBodyNone">It is a project template for PC (i.e. <b>MacOS</b>, <b>Windows</b> and <b>Linux</b>) using <b>VS Code + SDL2</b>   </td><td class="markdownTableBodyNone">examples/[template][pc][vscode]   </td><td class="markdownTableBodyNone"></td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <script type="text/javascript">
        <!--
        writeFooter.call(this);
        //-->
      </script> 
    </li>
  </ul>
</div>
</body>
</html>
