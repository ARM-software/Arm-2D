<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Arm-2D: Introduction for Arm-2D</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="footer.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../version.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../version.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 55px;">
  <td id="projectlogo" style="padding: 1.5em;"><img alt="Logo" src="arm.png"/></td>
  <td style="padding-left: 1em; padding-bottom: 1em;padding-top: 1em;">
   <div id="projectname">Arm-2D
   &#160;<span id="projectnumber"><script type="text/javascript">
     <!--
     writeHeader.call(this);
     writeVersionDropdown(this);
     //-->
    </script>
   </span>
   </div>
   <div id="projectbrief">2D Image Processing Library for Cortex-M Processors</div>
  </td>
  <!--END !PROJECT_NAME-->
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('intro.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Introduction for Arm-2D </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_introduction"></a> This document explains the basic concepts of Arm-2D. It doesn't matter whether you have read the <b>README</b> in the root directory. The content is suitable for everyone.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
1 Overview</h1>
<p >At the beginning of our adventure, you might have a lot of questions, such as</p>
<ul>
<li>What is Arm-2D?</li>
<li>What problems does it solve?</li>
<li>Who are the target audiences?</li>
<li>What does Arm-2D consist of?</li>
<li>What about the development environment?</li>
</ul>
<p >You will find the answers in the following sections.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
1.1 What is Arm-2D</h2>
<p >If you want to design GUI applications in Linux, you donâ€™t have to face hardware directly. The Linux ecosystem provides you with all necessary software components, including GPU drivers, GUI stacks and many handy reference designs.</p>
<p >Unfortunately, if you are an embedded developer using Cortex-M devices, you must face various display hardware directly. Even worse, you might face various non-standard 2D graphics accelerators from different silicon vendors. Many GUI stacks are available for embedded applications, but most of them are not ready for your target device immediately. As a result, you have to do the porting work first. In summary, using GUI in the Cortex-M system is feasible, but there is a lot of low-level work beforehand.</p>
<p ><b>Figure 1-1 Ecosystem Comparison between Rich Embedded and Constraint Embedded System in GUI</b></p>
<p ><img src="TopReadme_1_2a.png" alt="" class="inline" title="Ecosystem Comparison between Rich and Constraint Embedded System in GUI"/></p>
<p ><b>Arm-2D is not about reinventing a GUI or competing with the existing GUI stacks.</b> The problem Arm-2D wants to solve is how to <b>provide a unified low-level hardware acceleration interface for all GUI stacks</b> so that high-level software service providers are freed from writing drivers for endlessly emerging non-standard hardware. Once Arm-2D becomes a bridge between GUI providers and chip manufacturers, everyone can do their best.</p>
<p ><b>Figure 1-2 The Hierarchy of a Typical Embedded GUI System.</b></p>
<p ><img src="TopReadme_1_2b.png" alt="" class="inline" title="The Hierarchy of a Typical Embedded GUI System"/></p>
<p ><b>Arm-2D focuses on low-level 2D image processing and provides a unified software interface for the various 2D accelerators.</b></p>
<h2><a class="anchor" id="autotoc_md29"></a>
1.2 Target Audiences</h2>
<p >There are three types of participants in arm-2d: GUI service providers, silicon vendors, and embedded software developers.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
1.2.1 GUI Service Provider</h3>
<p >GUI service providers can benefit from Arm-2D, which provides a standard interface for commonly used hardware acceleration. GUI service providers can use Arm-2D to get low-level acceleration by default. As a result, they are freed from writing drivers for hardware; and concentrate on improving the software and providing customisation services for their VIP customers.</p>
<h3><a class="anchor" id="autotoc_md31"></a>
1.2.2 Silicon Vendor</h3>
<p >Semiconductor manufacturers can benefit from Arm-2D. To save the efforts of learning new architectures, programmers want to use microcontrollers under the same architecture, and in most cases, that means using Cortex-M processors. Since devices use the same processor architecture, semiconductor manufacturers are motivated to introduce proprietary peripherals for differentiation. Introducing dedicated accelerators for 2D graphics has become the new trend. While differentiation in hardware brings benefits to end-users, it also inevitably introduces the problem of software fragmentation. Introducing a hardware abstract layer to mitigate the issue is common practice in software engineering. Arm-2D is such an abstract layer for various 2D graphic accelerations.</p>
<p >In an ideal condition, chip manufacturers only need to implement arm-2d compliant drivers for their hardware accelerators, and this is sufficient to get support from the mainstream GUI stacks.</p>
<h3><a class="anchor" id="autotoc_md32"></a>
1.2.3 Embedded Software Developers</h3>
<p >Most embedded software developers use devices with constrained resources. A typical system has less than 64KB FLASH and 4~32K SRAM. As a reference, a standard low-cost serial LCD (320*240 resolution and 65K colour) requires 150KB RAM for the display buffer, which is unaffordable.</p>
<p >Also, for such microcontrollers, most of the existing GUI stacks are too expensive to use in terms of memory footprint. On the other hand, many GUI applications are so simple that even some home-brew implementations are good enough to fulfil the requirements. In such cases, most existing GUI stacks are too heavy.</p>
<p >When one wants to build a GUI-based application from scratch with such resource-constrained microcontrollers, you either completely give up the idea of GUI or make trade-offs among the following options:</p>
<ul>
<li>Implement GUI using only simple shapes, such as points, lines, colour blocks, etc.</li>
<li>Bearing with low bandwidth in operations: read pixels from LCD's internal display buffer, modify and write them back</li>
<li>Only copy/send pre-stored pictures in ROM to LCD without any processing.</li>
<li>Using a technique called the Partial-Frame-Buffer to practise time-space-exchanging</li>
</ul>
<p >In conclusion, <b>in the past, it was hard to implement a modern-looking GUI in a bare-metal environment</b>. And now, Arm-2D provides a series of easy-to-use APIs to help users implement desired graphic effects using the so-called Partial-Frame-Buffer helper service. It is worth mentioning that the <b>PFB-backed design paradigm introduced by Arm-2D is transparent to upper-layer software</b>, which dramatically simplifies the application development in a bare-metal environment, i.e. <b>users can design applications as if there is a full frame buffer.</b></p>
<p ><b>In summary, Arm-2D enables many devices (traditionally unsuitable for modern-looking GUI) to implement a modern-looking GUI with a small memory footprint.</b></p>
<h2><a class="anchor" id="autotoc_md33"></a>
1.3 Arm-2D Libraries</h2>
<h3><a class="anchor" id="autotoc_md34"></a>
1.3.1 Standard Software Implementation</h3>
<p >As a starting point, Arm-2D provides a default software implementation for all algorithms. These software implementations are mainly written in the C language and occasionally include some local assembly acceleration. This ensures that Arm-2D can be used directly on all Cortex-M processors without modification.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
1.3.2 Helium Acceleration</h3>
<p >If you are using an Armv8.1-M processor, such as Cortex-M55, as long as you enable Helium support with compilation options, <b>Arm-2D library will automatically use Helium technology for acceleration</b>.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
1.3.4 Third-party Implementation</h3>
<p >Arm-2D has provided standard ways to add support for various third-party hardware accelerators. Although not included now, In the future, we will introduce templates, examples and documents to show how to add support for third-party hardware accelerators.</p>
<h3><a class="anchor" id="autotoc_md37"></a>
1.3.5 Arm Custom Instruction Support</h3>
<p >Arm-2D has provided standard ways to add support for 2D image processing algorithms accelerated with customised instructions. Although not included now, In the future, we will introduce templates, examples and documents to show how.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
1.4 Scope and Limitations</h2>
<h3><a class="anchor" id="autotoc_md39"></a>
1.4.1 Scope</h3>
<ul>
<li>The Arm-2D should fulfil the requirements of Smart-Watch applications<ul>
<li>at most 640 * 640 resolution, 32bit colours</li>
<li>60 FPS refresh rate</li>
<li>Provide support for rotation, anti-alias filters etc.</li>
</ul>
</li>
<li>The Arm-2D should fulfil the requirements of deep embedded applications in constraint environment<ul>
<li>A typical MCU with less than 64K Flash and 4~32K SRAM.</li>
<li>System frequency is around 48MHz or above.</li>
<li>For applications that tolerate low frame-rate ranging from 1FPS to 30FPS.</li>
<li>Deliver modern-looking GUI using Partial Frame-buffer (as small as 8*8 PFB, 128Bytes in 16bit colour).<ul>
<li>Put no limitation on supported resolution size (exchanging RAM with low frame-rate).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md40"></a>
1.4.2 Limitations</h3>
<ul>
<li>The library focus on Cortex-M processors in principle.</li>
<li>The library should be compiled with the following compilers:<ul>
<li>Arm Compiler 5</li>
<li>Arm Compiler 6</li>
<li>GCC</li>
<li>LLVM</li>
<li>IAR</li>
</ul>
</li>
<li>The library focus on <b>Low Level Pixel Processing Acceleration</b><ul>
<li>In principle, the library will <b>NOT</b> provide APIs for content creation, such as drawing shape, text display and etc, but simple draw point APIs.</li>
<li>In principle, the library will <b>NOT</b> provide data structures or related algorithms which are essential for creating a GUI, for example, element tree, GUI message handling and the tree traversal algorithms.</li>
</ul>
</li>
</ul>
<p ><b>NOTE: For the temporary limitations in current version, please check section 5.2 in README for details.</b></p>
<h2><a class="anchor" id="autotoc_md41"></a>
1.5 Operation Categories</h2>
<p ><b>Table 1-1 Summary of Operation Categories.</b></p>
<p ><img src="Introduction1_5_1.png" alt="" class="inline" title="Summary of Operation Categories."/></p>
<h2><a class="anchor" id="autotoc_md42"></a>
1.6 Folder Structures</h2>
<p ><b>Table 1-2 The Folder Structure of Arm-2d Root</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Folder and File   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Library</b>   </td><td class="markdownTableBodyNone">Folder   </td><td class="markdownTableBodyNone">This folder contains the source files and header files of the library.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Helper</b>   </td><td class="markdownTableBodyNone">Folder   </td><td class="markdownTableBodyNone">This folder contains the source files and header files of helper functions / services.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">documentation   </td><td class="markdownTableBodyNone">Folder   </td><td class="markdownTableBodyNone">This folder contains all the documents.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">examples   </td><td class="markdownTableBodyNone">Folder   </td><td class="markdownTableBodyNone">This folder contains all the example code / projects.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">README   </td><td class="markdownTableBodyNone">.md   </td><td class="markdownTableBodyNone">The README.md you are currently reading.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">how_to_deploy_the_arm_2d_library   </td><td class="markdownTableBodyNone">.md   </td><td class="markdownTableBodyNone">A step by step guidance helping you to deploy the Arm-2D library to your projects.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">LICENSE   </td><td class="markdownTableBodyNone">License   </td><td class="markdownTableBodyNone">The Apache 2.0 License    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">tools   </td><td class="markdownTableBodyNone">Folder   </td><td class="markdownTableBodyNone">This folder contains some useful utilities for using the library. For example, img2c.py is a python script that convert a specified picture into the tile data structure.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md43"></a>
2 Basics</h1>
<p >Arm-2D defines some basic data structures for ease of use, providing a unified description method for various graphic resources and simplifying the parameters that need to be passed to 2D processing APIs. This chapter will introduce some basic concepts and corresponding data structures that you must know to work with the Arm-2D library. Arm-2D systematically introduces a Boxing Model to provide more sophisticated and easy to use 2D graphics operations.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
2.1 Region</h2>
<p >Region is a rectangular area described by the Location (the coordinates of the upper left corner) and the Size information.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a> {</div>
<div class="line">    <a class="code hl_function" href="group__gKernel.html#a09d46c454557ffa5e11df6d8797a7eb5" title="the location (top-left corner)">implement_ex</a>(<a class="code hl_struct" href="group__gKernel.html#structarm__2d__location__t" title="a type for coordinates (integer)">arm_2d_location_t</a>, tLocation);</div>
<div class="line">    <a class="code hl_function" href="group__gKernel.html#a09d46c454557ffa5e11df6d8797a7eb5" title="the location (top-left corner)">implement_ex</a>(<a class="code hl_struct" href="group__gKernel.html#structarm__2d__size__t" title="a type for the size of an rectangular area">arm_2d_size_t</a>, tSize);</div>
<div class="line">} <a class="code hl_struct" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a>;</div>
</div><!-- fragment --><p >**Figure 2-1 Region with Location and Size **</p>
<p ><img src="Introduction2_1a.png" alt="" class="inline" title="Region with Location and Size"/></p>
<h3><a class="anchor" id="autotoc_md45"></a>
2.1.1 Location</h3>
<p >The coordinate of the Region is defined by the vertices at the upper left corner of the bit rectangle. Its data structure is as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="group__gKernel.html#structarm__2d__location__t" title="a type for coordinates (integer)">arm_2d_location_t</a> {</div>
<div class="line">    int16_t <a class="code hl_variable" href="group__gKernel.html#afcfe4e9ad6eb4f402d0001a14d888e5f" title="x in Cartesian coordinate system">iX</a>;</div>
<div class="line">    int16_t <a class="code hl_variable" href="group__gKernel.html#ab6746d623416d076c3339cc9b44289b6" title="y in Cartesian coordinate system">iY</a>;</div>
<div class="line">} <a class="code hl_struct" href="group__gKernel.html#structarm__2d__location__t" title="a type for coordinates (integer)">arm_2d_location_t</a>;</div>
</div><!-- fragment --><p >Different from the general Cartesian coordinate system, in graphics, the Y-axis is usually mirrored in the opposite direction, which means that the lower the Y coordinate is, the larger the Y coordinate is. In the Boxing model that will be introduced later, we will understand that the <b>coordinates of a Region can be negative</b>, representing the position of the current Region relative to the starting point of its parent Region.</p>
<p ><b>Figure 2-2 When Location has a negative coordinates.</b></p>
<p ><img src="Introduction2_1b.png" alt="" class="inline" title="When Location has a negative coordinates"/></p>
<p >As shown in <b>Figure 2-2</b>, when the <em><b>x</b></em> and <em><b>y</b></em> coordinates of a Region are both negative, it actually has a considerable area outside (upper left corner) of its parent Region. When we try to find the intersection of the current Region and its parent Region, we will find that only part of the region is valid.</p>
<h3><a class="anchor" id="autotoc_md46"></a>
2.1.2 Size</h3>
<p >The size information of the Region is described by the Height and Width together. The data structure is defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="group__gKernel.html#structarm__2d__size__t" title="a type for the size of an rectangular area">arm_2d_size_t</a> {</div>
<div class="line">    int16_t <a class="code hl_variable" href="group__gKernel.html#a1aeaa9f863c682c26e8070d575667842" title="width of an rectangular area">iWidth</a>;</div>
<div class="line">    int16_t <a class="code hl_variable" href="group__gKernel.html#a44f7520235d22c8906b2c192442a0c31" title="height of an rectangular area">iHeight</a>;</div>
<div class="line">} <a class="code hl_struct" href="group__gKernel.html#structarm__2d__size__t" title="a type for the size of an rectangular area">arm_2d_size_t</a>;</div>
</div><!-- fragment --><p >Although a signed type <em><b>int16_t</b></em> is used to describe the width and height, negative numbers are meaningless and should be avoided.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
2.2 Boxing Model</h2>
<p >The so-called Boxing Model describes the affiliation between Regions, which is often used to describe the relationship between containers and visual elements.</p>
<p >In a GUI stack, the Boxing Model usually talks about more complex stuff, such as the border's width, the margin inside a container border, the padding of / distance between the elements inside a container etc. Arm-2D does <em><b>NOT</b></em> cares about these details but only describes the simple relationship between a container and the elements inside.</p>
<h3><a class="anchor" id="autotoc_md48"></a>
2.2.1 Absolute Location and Relative Location</h3>
<p >In Arm-2d, we consider panels or windows as containers, and the Locations of the panels and the windows are their coordinates in the display buffer. <b>We call this kind of location information that directly describes the coordinates in a display buffer as an Absolute Location</b>. In <b>Figure 2-3</b>, the panel (top container) coordinates are absolute coordinates.</p>
<p >The coordinates of the elements inside a container are described as <b>coordinates relative to the upper left corner of the parent container</b>. We call this kind of Locations the <b>Relative Locations</b>. In addition to that, since the container is only a special element, container nesting becomes possible. In <b>Figure 2-3</b>, the two innermost Regions have Relative Locations.</p>
<p ><b>Figure 2-3 A Typical Example of Absolute Locations and Relative Locations</b></p>
<p ><img src="Introduction2_2a.png" alt="" class="inline" title="A Typical Example of Absolute Locations and Relative Locations"/></p>
<h3><a class="anchor" id="autotoc_md49"></a>
2.2.2 Absolute Region and Relative Region</h3>
<p >If a Region has absolute Location, it is an <b>Absolute Region</b>; similarly, if a Region has relative Location, it is a <b>Relative Region</b>.</p>
<p ><b>Figure 2-4 A Typical Example of Absolute Regions and Relative Regions</b></p>
<p ><img src="Introduction2_2b.png" alt="" class="inline" title="A Typical Example of Absolute Regions and Relative Regions"/></p>
<p >When we use these relative and absolute information to perform visual area calculations, it is easy to exclude those areas that are actually invisible to the user from various graphic operations, thereby improving the overall 2D processing performance (as shown in <b>Figure 2-4</b> ).</p>
<h2><a class="anchor" id="autotoc_md50"></a>
2.3 Tile</h2>
<p >Tile is the smallest unit of various 2D operations in Arm-2D. The Tile data structure consists of three parts:</p>
<ul>
<li>Feature of the Tile</li>
<li>Region of the Tile and</li>
<li>Pointers</li>
</ul>
<p >The C definition of a the Tile data structure is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> <a class="code hl_struct" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a>;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> {</div>
<div class="line">    implement_ex(<span class="keyword">struct</span> {</div>
<div class="line">        uint8_t    bIsRoot              : 1;</div>
<div class="line">        uint8_t    bHasEnforcedColour   : 1;</div>
<div class="line">        uint8_t    bDerivedResource     : 1;</div>
<div class="line">        uint8_t                         : 5;</div>
<div class="line">        uint8_t                         : 8;</div>
<div class="line">        uint8_t                         : 8;</div>
<div class="line">        <a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__info__t" title="a type used as colour descriptor">arm_2d_color_info_t</a>    tColourInfo;</div>
<div class="line">    }, tInfo);</div>
<div class="line"> </div>
<div class="line">    implement_ex(<a class="code hl_struct" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a>, tRegion);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">union </span>{<span class="comment"></span></div>
<div class="line"><span class="comment">        /*! when bIsRoot is true, phwBuffer is available,</span></div>
<div class="line"><span class="comment">         *! otherwise ptParent is available</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <a class="code hl_struct" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a>       *ptParent;</div>
<div class="line">        uint8_t             *pchBuffer;</div>
<div class="line">        uint16_t            *phwBuffer;</div>
<div class="line">        uint32_t            *pwBuffer;</div>
<div class="line">        </div>
<div class="line">        intptr_t            nAddress;</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p >**Table 2-1 The Functionality of Each Members In *arm_2d_tile_t***</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Member   </th><th class="markdownTableHeadNone">Category   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Note    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>bIsRoot</b></em>   </td><td class="markdownTableBodyNone">Feature Info   </td><td class="markdownTableBodyNone">bit-field   </td><td class="markdownTableBodyNone">This bit indicates that whether a tile is a root tile or not. If it is "***1***", the target tile is a root tile that contains a pointer pointing to a display buffer. If it is "***0***", the target tile is a child tile that contains a pointer pointing to a parent tile which <b>NOT</b> necessarily to be a root tile.   </td><td class="markdownTableBodyNone">See <b><a href="#231-root-tile">section 2.3.1</a></b> and <b><a href="#232-child-tile">2.3.2</a></b> for details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>bHasEnforcedColour</b></em>   </td><td class="markdownTableBodyNone">Feature Info   </td><td class="markdownTableBodyNone">bit-field   </td><td class="markdownTableBodyNone">This bit indicates that whether a tile explicitly contains a descriptor for pixel colour. When this bit is set, <em><b>tColourInfo</b></em> is valid; otherwise, it is seen as containing no valid information. If a Tile is used as the source tile of any Colour Conversion Operations, this bit has to be set and <em><b>tColourInfo</b></em> should contain a valid description.   </td><td class="markdownTableBodyNone">For most of the Arm-2d operations, when this bit is zero, arm-2d API will use its own implicit understanding about the tile colour. For example, <em><b>arm_2d_rgb16_tile_copy()</b></em> has describe its implicit colour, i.e. <em><b>RGB16</b></em> in function name, hence even <em><b>bHasEnforcedColour</b></em> is set and <em><b>tColourInfo</b></em> contains valid information, the operation still considers both the source and target tiles using <em><b>RGB16</b></em>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>bDerivedResource</b></em>   </td><td class="markdownTableBodyNone">Feature Info   </td><td class="markdownTableBodyNone">bit-field   </td><td class="markdownTableBodyNone">This bit indicates whether a child tile is used as a resource.   </td><td class="markdownTableBodyNone">When creating a resource from a existing tile, you must set this bit to "1". <b>It is only valid when bIsRoot is "0"</b>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>tColourInfo</b></em>   </td><td class="markdownTableBodyNone">Feature Info   </td><td class="markdownTableBodyNone"><em><b><a class="el" href="group__gKernel.html#unionarm__2d__color__info__t" title="a type used as colour descriptor">arm_2d_color_info_t</a></b></em>   </td><td class="markdownTableBodyNone">When <em><b>bHasEnforcedColour</b></em> is set, tColourInfo should contain a valid descriptor about the colour used in the target Tile.   </td><td class="markdownTableBodyNone">See <b><a href="#24-colour">section 2.4</a></b> for details.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>tRegion</b></em>   </td><td class="markdownTableBodyNone">Region   </td><td class="markdownTableBodyNone"><em><b><a class="el" href="group__gKernel.html#structarm__2d__region__t" title="a type for an rectangular area">arm_2d_region_t</a></b></em>   </td><td class="markdownTableBodyNone">Depends on the type of a given tile, <em><b>tRegion</b></em> has a different meaning.   </td><td class="markdownTableBodyNone">See <b><a href="#231-root-tile">section 2.3.1</a></b> and <b><a href="#232-child-tile">2.3.2</a></b> for details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>ptParent</b></em>   </td><td class="markdownTableBodyNone">Pointers   </td><td class="markdownTableBodyNone"><em><b><a class="el" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> *</b></em>   </td><td class="markdownTableBodyNone">When <em><b>bIsRoot</b></em> is "***0***", this pointer is used to point the parent tile.   </td><td class="markdownTableBodyNone">See <b><a href="#231-root-tile">section 2.3.1</a></b> for details.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>phwBuffer</b></em>   </td><td class="markdownTableBodyNone">Pointers   </td><td class="markdownTableBodyNone"><em><b>uint16_t *</b></em>   </td><td class="markdownTableBodyNone">When <em><b>bIsRoot</b></em> is "***1***", this pointer is used to point to a display buffer that contains 16-bit pixels.   </td><td class="markdownTableBodyNone">See <b><a href="#231-root-tile">section 2.3.1</a></b> for details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>pwBuffer</b></em>   </td><td class="markdownTableBodyNone">Pointers   </td><td class="markdownTableBodyNone"><em><b>uint32_t *</b></em>   </td><td class="markdownTableBodyNone">When <em><b>bIsRoot</b></em> is "***1***", this pointer is used to point to a display buffer that contains 32-bit pixels.   </td><td class="markdownTableBodyNone">See <b><a href="#231-root-tile">section 2.3.1</a></b> for details.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>pchBuffer</b></em>   </td><td class="markdownTableBodyNone">Pointers   </td><td class="markdownTableBodyNone"><em><b>uint8_t *</b></em>   </td><td class="markdownTableBodyNone">When <em><b>bIsRoot</b></em> is "***1***", this pointer is used to point to a display buffer that contains pixels that have less or equals to 8bits.   </td><td class="markdownTableBodyNone">See <b><a href="#231-root-tile">section 2.3.1</a></b> for details.   </td></tr>
</table>
<p >[]:</p>
<h3><a class="anchor" id="autotoc_md51"></a>
2.3.1 Root Tile</h3>
<p >A Root tile is a kind of tiles that directly contain the display buffer, and its feature bit <code>bIsRoot</code> is set, according to the pixel types used in the display buffer to which corresponding pointers should be used. For more details, please refer to <b>Table 2-1</b>.</p>
<p >It is worth emphasizing that for a root Tile, its Location coordinate must be <em><b>(0,0)</b></em>; otherwise, it is considered illegal.</p>
<p >With the help of <a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">C99 designator</a>, a tile structure can be initialised clearly and easily. The following example shows a root tile <code>c_tPictureCMSISLogo</code> representing a <em><b>RGBA8888</b></em> bitmap stored in a constant array called <code>c_bmpCMSISLogo[]</code>. Note that because the bitmap and the tile structure are designated as constants, it is highly likely that a compiler will use ROM rather than RAM to store them and keep a small RAM footprint.</p>
<div class="fragment"><div class="line"><span class="comment">/*! picture cmsis_logo */</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> uint8_t c_bmpCMSISLogo[163 * 65 * <span class="keyword">sizeof</span>(uint32_t)];</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">static</span> <a class="code hl_struct" href="group__gKernel.html#structarm__2d__tile__t" title="a type for tile">arm_2d_tile_t</a> c_tPictureCMSISLogo = {</div>
<div class="line">    .tRegion = {</div>
<div class="line">        .tSize = {</div>
<div class="line">            .iWidth = 163,</div>
<div class="line">            .iHeight = 65</div>
<div class="line">        },</div>
<div class="line">    },</div>
<div class="line">    .tInfo = {</div>
<div class="line">        .bIsRoot = <span class="keyword">true</span>,</div>
<div class="line">        .bHasEnforcedColour = <span class="keyword">true</span>,</div>
<div class="line">        .tColourInfo = {</div>
<div class="line">            .chScheme = ARM_2D_COLOUR_RGBA8888,</div>
<div class="line">        },</div>
<div class="line">    },</div>
<div class="line">    .pwBuffer = (uint32_t *)c_bmpCMSISLogo,</div>
<div class="line">};</div>
</div><!-- fragment --><p >In fact, with the help of some macros, we can use Tile to implement the concept of the so-called visual layer:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define __declare_tile(__NAME)                                      \</span></div>
<div class="line"><span class="preprocessor">            extern const arm_2d_tile_t __NAME;</span></div>
<div class="line"><span class="preprocessor">#define declare_tile(__NAME)            __declare_tile(__NAME)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define __implement_tile(__NAME, __WIDTH, __HEIGHT, __TYPE)         \</span></div>
<div class="line"><span class="preprocessor">            ARM_NOINIT static __TYPE                                \</span></div>
<div class="line"><span class="preprocessor">                __NAME##Buffer[(__WIDTH) * (__HEIGHT)];             \</span></div>
<div class="line"><span class="preprocessor">            const arm_2d_tile_t __NAME = {                          \</span></div>
<div class="line"><span class="preprocessor">                .tRegion = {                                        \</span></div>
<div class="line"><span class="preprocessor">                    .tSize = {(__WIDTH), (__HEIGHT)},               \</span></div>
<div class="line"><span class="preprocessor">                },                                                  \</span></div>
<div class="line"><span class="preprocessor">                .tInfo.bIsRoot = true,                              \</span></div>
<div class="line"><span class="preprocessor">                .pchBuffer = (uint8_t *)__NAME##Buffer,             \</span></div>
<div class="line"><span class="preprocessor">            }</span></div>
<div class="line">            </div>
<div class="line"><span class="preprocessor">#define implement_tile(__NAME, __WIDTH, __HEIGHT, __TYPE)           \</span></div>
<div class="line"><span class="preprocessor">            __implement_tile(__NAME, __WIDTH, __HEIGHT, __TYPE)</span></div>
</div><!-- fragment --><p >For example, we can create two visual layers with size <b>100*100</b> and <em><b>200*50</b></em> respectively and using colour <code><a class="el" href="group__gKernel.html#unionarm__2d__color__rgb565__t" title="the colour type for rgb565">arm_2d_color_rgb565_t</a></code> for pixels:</p>
<div class="fragment"><div class="line">declare_tile(c_tLayerA)</div>
<div class="line">implement_tile(c_tLayerA, 100, 100, <a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__rgb565__t" title="the colour type for rgb565">arm_2d_color_rgb565_t</a>);</div>
<div class="line"> </div>
<div class="line">declare_tile(c_tLayerB)</div>
<div class="line">implement_tile(c_tLayerB, 200, 50, <a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__rgb565__t" title="the colour type for rgb565">arm_2d_color_rgb565_t</a>);</div>
</div><!-- fragment --><p >These layers are stored in RAM, which are used as sources and targets for 2D operations.</p>
<p >Note that in the aforementioned macro template, we use <code>ARM_NOINIT</code> to decorate the display buffer, its definition is shown below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ARM_NOINIT</span></div>
<div class="line"><span class="preprocessor">#if     defined(__IS_COMPILER_ARM_COMPILER_5__)</span></div>
<div class="line"><span class="preprocessor">#   define ARM_NOINIT           __attribute__( ( section( &quot;.bss.noinit&quot;</span>),zero_init) )</div>
<div class="line"><span class="preprocessor">#elif   defined(__IS_COMPILER_ARM_COMPILER_6__)</span></div>
<div class="line"><span class="preprocessor">#   define ARM_NOINIT           __attribute__( ( section( &quot;.bss.noinit&quot;</span>)) )</div>
<div class="line"><span class="preprocessor">#elif   defined(__IS_COMPILER_IAR__)</span></div>
<div class="line"><span class="preprocessor">#   define ARM_NOINIT           __no_init</span></div>
<div class="line"><span class="preprocessor">#elif   defined(__IS_COMPILER_GCC__) || defined(__IS_COMPILER_LLVM__)</span></div>
<div class="line"><span class="preprocessor">#   define ARM_NOINIT           __attribute__(( __section__( &quot;.bss.noinit&quot;</span>)))</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#   define ARM_NOINIT</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p >It is clear that for the Arm Compiler 5 and Arm Compiler 6, <code>ARM_NOINIT</code> puts the target variable into a <em><b>ZI</b></em> section called <code>.bss.noinit</code> which later should be placed in an execution region with <em><b><a href="https://developer.arm.com/documentation/101754/0616/armlink-Reference/Scatter-File-Syntax/Execution-region-descriptions/Execution-region-attributes">UNINIT</a></b></em> feature in a scatter-script, for example:</p>
<div class="fragment"><div class="line">LR_ROM __ROM_BASE __ROM_SIZE  {                           </div>
<div class="line">    ...</div>
<div class="line">    ; Reserve empty region for stack</div>
<div class="line">    ARM_LIB_STACK __RAM1_BASE ALIGN 8 EMPTY __STACK_SIZE { </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    RW_RAM1 +0 __RAM1_RW_SIZE {</div>
<div class="line">        * (+RO-DATA)</div>
<div class="line">        * (+RW +ZI)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    RM_RAM_NOINIT +0 UNINIT {</div>
<div class="line">        * (.bss.noinit)</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ; Reserve empty region for heap</div>
<div class="line">    ARM_LIB_HEAP  __HEAP_BASE ALIGN 8 EMPTY __HEAP_SIZE  { </div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md52"></a>
2.3.2 Child Tile</h3>
<p >Given any tile, we can derive a theoretically unlimited number of sub-tiles based on it, which are called Child Tiles in Arm-2D. It is worth emphasizing that the Tile that can be used to derive child tiles does not need to be a root Tile. The <code>bIsRoot</code> flag of the Child Tile is 0, which means that the pointer<code>ptParent</code> points to its parent Tile.</p>
<p >The Location information of the child tile is used to indicate its location in the parent tile. Negative numbers are allowed for the coordinates here. The region of a child tile can be larger than the size of the parent tile. This is often used to implement the Partial Frame-buffer. For more, please refer to <b><a href="#233-partial-frame-buffer">section 2.3.3</a></b>.</p>
<p ><b>Figure 2-3</b> shows a series of Child Tiles, and their derivation relationship in the form of Region View.</p>
<p ><b>Figure 2-3 A Chain of Child Tiles and Their Root Tile</b></p>
<p ><img src="Introduction2_3a.png" alt="" class="inline" title="A Chain of Child Tiles and Their Root Tile"/></p>
<p >The introduction of Child Tiles can greatly simplify the storing and representing of GUI resources. Smart designers can even put many image elements in the same picture and retrieve them by creating Child Tiles with different sizes from different locations. In practice, A multi-level Child Tile suffers almost no performance loss in 2D operations.</p>
<h3><a class="anchor" id="autotoc_md53"></a>
2.3.3 Partial Frame Buffer</h3>
<p >The so-called Partial Frame Buffer is a special use of the Tile Child scheme. It establishes a root Tile for a tiny rectangular display buffer and derives a Child Tile having the same size as the actual screen. In practice, the GUI software in the upper layer uses the Child Tile (with the full-screen size) to draw graphics and blend visual layers. After completing a frame, the PFB that actually saves the pixel information is sent to the LCD driver for a flush. Since FPB only covers a small area, the drawing process aforementioned, in most cases, will be judged as "no need for actual drawing" and skipped. To display the entire screen, we need to repeat this process continuously and adjust the relative Location between FPB and the Child Tile at the beginning of each iteration. For us, it looks like moving FPB line by line on the screen as shown in <b>Figure 2-4</b>.</p>
<p ><b>Figure 2-4 How Partial Frame Buffer Works</b></p>
<p ><img src="Introduction2_3b.png" alt="" class="inline" title="How Partial Frame Buffer Works"/></p>
<p >More details are shown in a dedicated example project located in <code>examples/benchmark</code> directory.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
2.4 Colour</h2>
<p >Arm-2D has reserved sufficient space for supporting more colour formats. A data structure has been introduced to describe a colour format used in a given tile. The C definition is shown below:</p>
<div class="fragment"><div class="line"><span class="comment">/*! </span></div>
<div class="line"><span class="comment"> * \brief enumerations for colour attributes</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">enum</span> {</div>
<div class="line">    <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55bab09ded11990cfc6a1f0fc7560453a04c" title="1 bit:black and white">ARM_2D_COLOUR_SZ_1BIT</a> = 0,            <span class="comment">//!&lt; 1 bit:black and white</span></div>
<div class="line">    <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55baff422fcf70493703facea1473d9c3fc1" title="4 colours or 4 gray-levels">ARM_2D_COLOUR_SZ_2BIT</a> = 1,            <span class="comment">//!&lt; 4 colours or 4 gray-levels</span></div>
<div class="line">    <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55bac063df9d23d0a8dd6234003636dacf9e" title="16 colours or 16 gray-levels">ARM_2D_COLOUR_SZ_4BIT</a> = 2,            <span class="comment">//!&lt; 16 colours or 16 gray-levels</span></div>
<div class="line">    <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55ba96378d24be8aabb704be24a9c06fad2b" title="256 colours">ARM_2D_COLOUR_SZ_8BIT</a> = 3,            <span class="comment">//!&lt; 256 colours</span></div>
<div class="line">    <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55baa581a9deb872893773fe7c5f615f1771" title="16bits">ARM_2D_COLOUR_SZ_16BIT</a> = 4,           <span class="comment">//!&lt; 16bits</span></div>
<div class="line">    <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55bab73d9139521893b7600e21c84c091614" title="true colour">ARM_2D_COLOUR_SZ_32BIT</a> = 5,           <span class="comment">//!&lt; true colour</span></div>
<div class="line"> </div>
<div class="line">    ARM_2D_COLOUR_SZ_1BIT_msk =   <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55bab09ded11990cfc6a1f0fc7560453a04c" title="1 bit:black and white">ARM_2D_COLOUR_SZ_1BIT</a> &lt;&lt; 1,</div>
<div class="line">    ARM_2D_COLOUR_SZ_2BIT_msk =   <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55baff422fcf70493703facea1473d9c3fc1" title="4 colours or 4 gray-levels">ARM_2D_COLOUR_SZ_2BIT</a> &lt;&lt; 1,</div>
<div class="line">    ARM_2D_COLOUR_SZ_4BIT_msk =   <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55bac063df9d23d0a8dd6234003636dacf9e" title="16 colours or 16 gray-levels">ARM_2D_COLOUR_SZ_4BIT</a> &lt;&lt; 1,</div>
<div class="line">    ARM_2D_COLOUR_SZ_8BIT_msk =   <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55ba96378d24be8aabb704be24a9c06fad2b" title="256 colours">ARM_2D_COLOUR_SZ_8BIT</a> &lt;&lt; 1,</div>
<div class="line">    ARM_2D_COLOUR_SZ_16BIT_msk =  <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55baa581a9deb872893773fe7c5f615f1771" title="16bits">ARM_2D_COLOUR_SZ_16BIT</a>&lt;&lt; 1,</div>
<div class="line">    ARM_2D_COLOUR_SZ_32BIT_msk =  <a class="code hl_enumvalue" href="group__gKernel.html#gga06fc87d81c62e9abb8790b6e5713c55bab73d9139521893b7600e21c84c091614" title="true colour">ARM_2D_COLOUR_SZ_32BIT</a>&lt;&lt; 1,</div>
<div class="line">    ARM_2D_COLOUR_SZ_msk      =   (0x07 &lt;&lt; 1),</div>
<div class="line"> </div>
<div class="line">    ARM_2D_COLOUR_LITTLE_ENDIAN       = 0,</div>
<div class="line">    ARM_2D_COLOUR_BIG_ENDIAN          = 1,</div>
<div class="line"> </div>
<div class="line">    ARM_2D_COLOUR_LITTLE_ENDIAN_msk   = ARM_2D_COLOUR_LITTLE_ENDIAN &lt;&lt; 4,</div>
<div class="line">    ARM_2D_COLOUR_BIG_ENDIAN_msk      = ARM_2D_COLOUR_BIG_ENDIAN    &lt;&lt; 4,</div>
<div class="line"> </div>
<div class="line">    ARM_2D_COLOUR_NO_ALPHA = 0,</div>
<div class="line">    ARM_2D_COLOUR_HAS_ALPHA = 1,</div>
<div class="line"> </div>
<div class="line">    ARM_2D_COLOUR_NO_ALPHA_msk        = ARM_2D_COLOUR_NO_ALPHA      &lt;&lt; 0,</div>
<div class="line">    ARM_2D_COLOUR_HAS_ALPHA_msk       = ARM_2D_COLOUR_HAS_ALPHA     &lt;&lt; 0,</div>
<div class="line">    </div>
<div class="line">    ARM_2D_COLOUR_VARIANT_pos = 5,</div>
<div class="line">    ARM_2D_COLOUR_VARIANT_msk         = 0x07 &lt;&lt; ARM_2D_COLOUR_VARIANT_pos,</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*!</span></div>
<div class="line"><span class="comment"> * \brief enumerations for colour types</span></div>
<div class="line"><span class="comment"> * </span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">enum</span> {</div>
<div class="line">    ARM_2D_COLOUR_BIN         =   ARM_2D_COLOUR_SZ_1BIT_msk,</div>
<div class="line">    ARM_2D_COLOUR_1BIT        =   ARM_2D_COLOUR_SZ_1BIT_msk,</div>
<div class="line">    </div>
<div class="line">    ARM_2D_COLOUR_8BIT        =   ARM_2D_COLOUR_SZ_8BIT_msk,</div>
<div class="line">    ARM_2D_COLOUR_GRAY8       =   ARM_2D_COLOUR_SZ_8BIT_msk,</div>
<div class="line">    </div>
<div class="line">    ARM_2D_COLOUR_16BIT       =   ARM_2D_COLOUR_SZ_16BIT_msk,</div>
<div class="line">    ARM_2D_COLOUR_RGB16       =   ARM_2D_COLOUR_SZ_16BIT_msk,</div>
<div class="line">    ARM_2D_COLOUR_RGB565      =   ARM_2D_COLOUR_RGB16,</div>
<div class="line">    </div>
<div class="line"><span class="comment">/*  won&#39;t support</span></div>
<div class="line"><span class="comment">    ARM_2D_COLOUR_RGB565_BE   =   ARM_2D_COLOUR_SZ_16BIT_msk        |</span></div>
<div class="line"><span class="comment">                                  ARM_2D_COLOUR_BIG_ENDIAN_msk      ,</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line">    ARM_2D_COLOUR_32BIT       =   ARM_2D_COLOUR_SZ_32BIT_msk        ,</div>
<div class="line">    ARM_2D_COLOUR_RGB32       =   ARM_2D_COLOUR_SZ_32BIT_msk        ,</div>
<div class="line"> </div>
<div class="line">    ARM_2D_COLOUR_CCCN888     =   ARM_2D_COLOUR_RGB32               ,</div>
<div class="line">    ARM_2D_COLOUR_CCCA8888    =   ARM_2D_COLOUR_SZ_32BIT_msk        |</div>
<div class="line">                                  ARM_2D_COLOUR_HAS_ALPHA_msk       ,</div>
<div class="line"> </div>
<div class="line">    ARM_2D_COLOUR_RGB888      =   ARM_2D_COLOUR_CCCN888             ,</div>
<div class="line">    ARM_2D_COLOUR_BGRA8888    =   ARM_2D_COLOUR_CCCA8888            ,</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* not supported yet</span></div>
<div class="line"><span class="comment">    ARM_2D_COLOUR_NCCC888     =   ARM_2D_COLOUR_RGB32               |</span></div>
<div class="line"><span class="comment">                                  ARM_2D_COLOUR_BIG_ENDIAN_msk      ,</span></div>
<div class="line"><span class="comment">    ARM_2D_COLOUR_ACCC8888    =   ARM_2D_COLOUR_SZ_32BIT_msk        |</span></div>
<div class="line"><span class="comment">                                  ARM_2D_COLOUR_HAS_ALPHA_msk       |</span></div>
<div class="line"><span class="comment">                                  ARM_2D_COLOUR_BIG_ENDIAN_msk      ,</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">    ARM_2D_CHANNEL_8in32      =   ARM_2D_COLOUR_SZ_32BIT_msk        |</div>
<div class="line">                                  ARM_2D_COLOUR_HAS_ALPHA_msk       |</div>
<div class="line">                                  ARM_2D_COLOUR_VARIANT_msk   ,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/*!</span></div>
<div class="line"><span class="comment"> * \brief a type used as colour descriptor</span></div>
<div class="line"><span class="comment"> * </span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span>{</div>
<div class="line">    <span class="keyword">struct </span>{</div>
<div class="line">        uint8_t bHasAlpha  : 1;     <span class="comment">//!&lt; whether the target colour has alpha channel</span></div>
<div class="line">        uint8_t u3ColourSZ : 3;     <span class="comment">//!&lt; the size of the colour</span></div>
<div class="line">        uint8_t bBigEndian : 1;     <span class="comment">//!&lt; whether the colour is stored in big endian</span></div>
<div class="line">        uint8_t u3Variant  : 3;</div>
<div class="line">    };</div>
<div class="line">    uint8_t chScheme;</div>
<div class="line">} <a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__info__t" title="a type used as colour descriptor">arm_2d_color_info_t</a>;</div>
</div><!-- fragment --><p ><b>Table 2-2 The Member of arm_2d_colour_info_t</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Member   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Note    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>bHasAlpha</b></em>   </td><td class="markdownTableBodyNone">bit-field   </td><td class="markdownTableBodyNone"><em><b>bHasAlpha</b></em> is used to indicate that whether the target colour format contains an alpha channel or not. Here â€œ***1***â€ means that the Alpha channel is included, and vice versa.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>u3ColourSZ</b></em>   </td><td class="markdownTableBodyNone">bit-field   </td><td class="markdownTableBodyNone"><em><b>u3ColourSZ</b></em> is used to indicate the data length of each pixel. The valid values are represented as enumerations starting with " ***ARM\_2D\_COLOUR_SZ\_*** ".   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>bBigEndian</b></em>   </td><td class="markdownTableBodyNone">bit-field   </td><td class="markdownTableBodyNone"><em><b>bBigEndian</b></em> is used to indicate whether the pixel is stored in Big-Endian.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>u3Variant</b></em>   </td><td class="markdownTableBodyNone">bit-field   </td><td class="markdownTableBodyNone">In some rare cases that the aforementioned bit fields refer to more than one colour format, the <em><b>u3Varient</b></em> can be used to encode at most 8 different variants.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>chScheme</b></em>   </td><td class="markdownTableBodyNone">uint8_t   </td><td class="markdownTableBodyNone">An 8bit representation of the bit fields aforementioned. It is very efficient in comparison. Enumerations starting with " ***ARM\_2D\_COLOUR\_*** " represent the colour formats currently supported in the Arm-2D library. For example, <em><b>ARM_2D_COLOUR_RGB565</b></em>.   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p >In addition to the colour format descriptor, the current version of the Arm-2D library also defines data structures for the supported colour formats:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span><a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__rgb565__t" title="the colour type for rgb565">arm_2d_color_rgb565_t</a> {</div>
<div class="line">    uint16_t tValue;</div>
<div class="line">    <span class="keyword">struct </span>{</div>
<div class="line">        uint16_t u5B : 5;</div>
<div class="line">        uint16_t u6G : 6;</div>
<div class="line">        uint16_t u5R : 5;</div>
<div class="line">    };</div>
<div class="line">} <a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__rgb565__t" title="the colour type for rgb565">arm_2d_color_rgb565_t</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span><a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__bgra8888__t" title="the colour type for brga8888">arm_2d_color_bgra8888_t</a> {</div>
<div class="line">    uint32_t tValue;</div>
<div class="line">    <span class="keyword">struct </span>{</div>
<div class="line">        uint32_t u8B : 8;</div>
<div class="line">        uint32_t u8G : 8;</div>
<div class="line">        uint32_t u8R : 8;</div>
<div class="line">        uint32_t u8A : 8;</div>
<div class="line">    };</div>
<div class="line">} <a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__bgra8888__t" title="the colour type for brga8888">arm_2d_color_bgra8888_t</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span><a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__rgb888__t" title="the colour type for rgb888 (compliant with ccca888 and bgra8888)">arm_2d_color_rgb888_t</a> {</div>
<div class="line">    uint32_t tValue;</div>
<div class="line">    <span class="keyword">struct </span>{</div>
<div class="line">        uint32_t u8B : 8;</div>
<div class="line">        uint32_t u8G : 8;</div>
<div class="line">        uint32_t u8R : 8;</div>
<div class="line">        uint32_t     : 8;</div>
<div class="line">    };</div>
<div class="line">} <a class="code hl_union" href="group__gKernel.html#unionarm__2d__color__rgb888__t" title="the colour type for rgb888 (compliant with ccca888 and bgra8888)">arm_2d_color_rgb888_t</a>;</div>
</div><!-- fragment --><p >As shown above, <b>arm-2d describes colour format in little-end manner</b>, for example, <b>BGRA8888</b> means the blue-channel is the 1st byte and the Alpha channel is the 3rd byte. The colour format CCCA8888 means the Alpha channel is the 3rd byte and there are three colour channels whose name and order we don't care. The colour format CCCN888 means the 8 MSB are unused (reserved for alpha) and the lower 3 bytes are used to store colour channels.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
2.4 API Usage Modes</h2>
<p >Arm-2D APIs can be used in both Synchronous mode and Asynchronous mode. In fact, The Arm-2D library is designed for working asynchronously, and wrappers are added to support synchronous mode.</p>
<h3><a class="anchor" id="autotoc_md56"></a>
2.4.1 Synchronous Mode</h3>
<p >The Synchronous mode is also known as the classic mode, in which a function call won't return until the service is finished or an error occurred. In the current version of the Arm-2D library, all examples are written in Synchronous mode.</p>
<h3><a class="anchor" id="autotoc_md57"></a>
2.4.2 Asynchronous Mode</h3>
<p >The Asynchronous mode is good for the event-driven design paradigm, and it is suitable for most of the RTOS based applications and applications that are written in protoThread and/or FSM in the bare-metal system.</p>
<p >The examples and documents for Asynchronous mode will be added soon.</p>
<h1><a class="anchor" id="autotoc_md58"></a>
3 API Summary</h1>
<h2><a class="anchor" id="autotoc_md59"></a>
3.1 Tile Operations</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">NOTE    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2d_is_root_tile</b></em>   </td><td class="markdownTableBodyNone">A function used to check whether a given tile is a root tile or not.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2d_region_intersect</b></em>   </td><td class="markdownTableBodyNone">A function used to perform region intersection.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2d_is_point_inside_region</b></em>   </td><td class="markdownTableBodyNone">A function used to check whether a point is inside a given region or not.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2d_tile_get_root</b></em>   </td><td class="markdownTableBodyNone">For a given tile, return its root tile and the valid region inside that root tile.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2d_tile_generate_child</b></em>   </td><td class="markdownTableBodyNone">Generate a Child Tile for a given Tile with a target region inside the given tile.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2d_tile_width_compare</b></em>   </td><td class="markdownTableBodyNone">compare the widths of two tiles   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2d_tile_height_compare</b></em>   </td><td class="markdownTableBodyNone">compare the heights of two tiles   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2d_tile_shape_compare</b></em>   </td><td class="markdownTableBodyNone">compare the shape (both widths and heights) of two tiles   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2d_get_absolute_location</b></em>   </td><td class="markdownTableBodyNone">calcualte the absolute location in the root tile for a given tile   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2d_tile_region_diff</b></em>   </td><td class="markdownTableBodyNone">calculate the region differences between two tiles   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_tile_copy</b></em>   </td><td class="markdownTableBodyNone">Copy or Fill a given tile into a target tile. Both tiles should use 8bits for each pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_tile_copy</b></em>   </td><td class="markdownTableBodyNone">Copy or Fill a given tile into a target tile. Both tiles should use 16bits for each pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_tile_copy</b></em>   </td><td class="markdownTableBodyNone">Copy or Fill a given tile into a target tile. Both tiles should use 32bits for each pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_tile_copy_only</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile. Both tiles should be 8bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_tile_copy_only</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile. Both tiles should be 16bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_tile_copy_only</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile. Both tiles should be 32bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_tile_copy_with_x_mirror</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile with x-mirroring. Both tiles should be 8bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_tile_copy_with_x_mirror</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile with x-mirroring. Both tiles should be 16bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_tile_copy_with_x_mirror</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile with x-mirroring. Both tiles should be 32bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_tile_copy_with_y_mirror</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile with y-mirroring. Both tiles should be 8bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_tile_copy_with_y_mirror</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile with y-mirroring. Both tiles should be 16bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_tile_copy_with_y_mirror</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile with y-mirroring. Both tiles should be 32bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_tile_copy_with_xy_mirror</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile with xy-mirroring. Both tiles should be 8bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_tile_copy_with_xy_mirror</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile with xy-mirroring. Both tiles should be 16bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_tile_copy_with_xy_mirror</b></em>   </td><td class="markdownTableBodyNone">copy a source tile to a given target tile with xy-mirroring. Both tiles should be 32bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_tile_fill_only</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile. Both tiles should be 8bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_tile_fill_only</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile. Both tiles should be 16bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_tile_fill_only</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile. Both tiles should be 32bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_tile_fill_with_x_mirror</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile in x-mirroring. Both tiles should be 8bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_tile_fill_with_x_mirror</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile in x-mirroring. Both tiles should be 16bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_tile_fill_with_x_mirror</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile in x-mirroring. Both tiles should be 32bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_tile_fill_with_y_mirror</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile in y-mirroring. Both tiles should be 8bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_tile_fill_with_y_mirror</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile in y-mirroring. Both tiles should be 16bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_tile_fill_with_y_mirror</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile in y-mirroring. Both tiles should be 32bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_tile_fill_with_xy_mirror</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile in xy-mirroring. Both tiles should be 8bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_tile_fill_with_xy_mirror</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile in xy-mirroring. Both tiles should be 16bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_tile_fill_with_xy_mirror</b></em>   </td><td class="markdownTableBodyNone">fill the target tile with a given source tile in xy-mirroring. Both tiles should be 32bit per pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_tile_copy_with_colour_keying</b></em>   </td><td class="markdownTableBodyNone">Copy a given tile into a target tile with the Colour-Keying scheme. Both tiles should use 8bits for each pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_tile_copy_with_colour_keying</b></em>   </td><td class="markdownTableBodyNone">Copy a given tile into a target tile with the Colour-Keying scheme. Both tiles should use 16bits for each pixel.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_tile_copy_with_colour_keying</b></em>   </td><td class="markdownTableBodyNone">Copy a given tile into a target tile with the Colour-Keying scheme. Both tiles should use 32bits for each pixel. No alpha channel is used in this function.   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<h2><a class="anchor" id="autotoc_md60"></a>
3.2 Colour Space Conversion</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">NOTE    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2d_convert_colour_to_rbg888</b></em>   </td><td class="markdownTableBodyNone">Convert a tile with any other colour format into a new tile with <em><b>RGB888</b></em>.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2d_convert_colour_to_rgb565</b></em>   </td><td class="markdownTableBodyNone">Convert a tile with any other colour format into a new tile with <em><b>RGB565</b></em>.   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<h2><a class="anchor" id="autotoc_md61"></a>
3.3 Alpha Blending</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">NOTE    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_alpha_blending</b></em>   </td><td class="markdownTableBodyNone">Blend a source tile to a target tile with a given transparency ratio. Both tiles should use <em><b>GRAY8</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb565_alpha_blending</b></em>   </td><td class="markdownTableBodyNone">Blend a source tile to a target tile with a given transparency ratio. Both tiles should use <em><b>RGB565</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_cccn888_alpha_blending</b></em>   </td><td class="markdownTableBodyNone">Blend a source tile to a target tile with a given transparency ratio. Both tiles should use <em><b>CCCN888</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_alpha_blending_with_colour_keying</b></em>   </td><td class="markdownTableBodyNone">Blend a source tile to a target tile with a given transparency ratio and the Colour-Keying scheme. Both tiles should use <em><b>GRAY8</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rbg565_alpha_blending_with_colour_keying</b></em>   </td><td class="markdownTableBodyNone">Blend a source tile to a target tile with a given transparency ratio and the Colour-Keying scheme. Both tiles should use <em><b>RGB565</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_cccn888_alpha_blending_with_colour_keying</b></em>   </td><td class="markdownTableBodyNone">Blend a source tile to a target tile with a given transparency ratio and the Colour-Keying scheme. Both tiles should use <em><b>RGB888</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_fill_colour_with_opacity</b></em>   </td><td class="markdownTableBodyNone">Fill a given region in the target tile with a specified <em><b>GRAY8</b></em> colour and opacity.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb565_fill_colour_with_opacity</b></em>   </td><td class="markdownTableBodyNone">Fill a given region in the target tile with a specified <em><b>RGB565</b></em> colour and opacity.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_cccn888_fill_colour_with_opacity</b></em>   </td><td class="markdownTableBodyNone">Fill a given region in the target tile with a specified <em><b>CCCN888</b></em> colour and opacity.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_fill_colour_with_mask</b></em>   </td><td class="markdownTableBodyNone">fill a target tile with a given <em><b>GRAY8</b></em> colour and a mask on target side   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb565_fill_colour_with_mask</b></em>   </td><td class="markdownTableBodyNone">fill a target tile with a given <em><b>RGB565</b></em> colour and a mask on target side   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_cccn888_fill_colour_with_mask</b></em>   </td><td class="markdownTableBodyNone">fill a target tile with a given <em><b>CCCN888</b></em> colour and a mask on target side   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_fill_colour_with_mask_and_opacity</b></em>   </td><td class="markdownTableBodyNone">fill a target tile with a given <em><b>GRAY8</b></em> colour, a mask on target side and an opacity   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb565_fill_colour_with_mask_and_opacity</b></em>   </td><td class="markdownTableBodyNone">fill a target tile with a given <em><b>RGB565</b></em> colour, a mask on target side and an opacity   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_cccn888_fill_colour_with_mask_and_opacity</b></em>   </td><td class="markdownTableBodyNone">fill a target tile with a given <em><b>CCCN888</b></em> colour, a mask on target side and an opacity   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_tile_copy_with_masks</b></em>   </td><td class="markdownTableBodyNone">copy or fill a source tile to a target tile with masks in a given mode. Both tiles use <em><b>GRAY8</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb565_tile_copy_with_masks</b></em>   </td><td class="markdownTableBodyNone">copy or fill a source tile to a target tile with masks in a given mode. Both tiles use <em><b>RGB565</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_CCCN888_tile_copy_with_masks</b></em>   </td><td class="markdownTableBodyNone">copy or fill a source tile to a target tile with masks in a given mode. Both tiles use <em><b>CCCN888</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_tile_copy_with_des_mask</b></em>   </td><td class="markdownTableBodyNone">copy or fill a source tile to a target tile with a mask on the target side in a given mode. Both tiles use <em><b>GRAY8</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb565_tile_copy_with_des_mask</b></em>   </td><td class="markdownTableBodyNone">copy or fill a source tile to a target tile with a mask on the target side in a given mode. Both tiles use <em><b>RGB565</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_cccn888_tile_copy_with_des_mask</b></em>   </td><td class="markdownTableBodyNone">copy or fill a source tile to a target tile with a mask on the target side in a given mode. Both tiles use <em><b>CCCN888</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_tile_copy_with_src_mask</b></em>   </td><td class="markdownTableBodyNone">copy or fill a source tile to a target tile with a mask on the source side in a given mode. Both tiles use <em><b>GRAY8</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb565_tile_copy_with_src_mask</b></em>   </td><td class="markdownTableBodyNone">copy or fill a source tile to a target tile with a mask on the source side in a given mode. Both tiles use <em><b>RGB565</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_cccn888_tile_copy_with_src_mask</b></em>   </td><td class="markdownTableBodyNone">copy or fill a source tile to a target tile with a mask on the source side in a given mode. Both tiles use <em><b>CCCN888</b></em> as their colour format.   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<h2><a class="anchor" id="autotoc_md62"></a>
3.4 Transform (Rotation/Scaling)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">NOTE    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_tile_transform_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform in <em><b>GRAY8</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb565_tile_transform_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform in <em><b>RGB565</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_cccn888_tile_transform_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform in <em><b>CCCN888</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_tile_transform_with_opacity_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform with opacity in <em><b>GRAY8</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb565_tile_transform_with_opacity_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform with opacity in <em><b>RGB565</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_cccn888_tile_transform_with_opacity_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform with opacity in <em><b>CCCN888</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_tile_transform_with_src_mask_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform with source mask in <em><b>GRAY8</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb565_tile_transform_with_src_mask_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform with source mask in <em><b>RGB565</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_cccn888_tile_transform_with_src_mask_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform with source mask in <em><b>CCCN888</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_gray8_tile_transform_with_src_mask_and_opacity_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform with source mask and opacity in <em><b>GRAY8</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb565_tile_transform_with_src_mask_and_opacity_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform with source mask and opacity in <em><b>RGB565</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_cccn888_tile_transform_with_src_mask_and_opacity_prepare</b></em>   </td><td class="markdownTableBodyNone">prepare for a transform with source mask and opacity in <em><b>CCCN888</b></em>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_tile_transform</b></em>   </td><td class="markdownTableBodyNone">start a transform operation   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<h2><a class="anchor" id="autotoc_md63"></a>
3.5 Drawing</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">NOTE    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2d_c8bit_draw_point_fast</b></em>   </td><td class="markdownTableBodyNone">Draw a 8bit pixel to a given root tile.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2d_rgb16_draw_point_fast</b></em>   </td><td class="markdownTableBodyNone">Draw a 16bit pixel to a given root tile.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2d_rgb32_draw_point_fast</b></em>   </td><td class="markdownTableBodyNone">Draw a 32bit pixel to a given root tile.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_draw_point</b></em>   </td><td class="markdownTableBodyNone">Draw a 8bit pixel to a given tile. This function is relatively slower than the "***\_fast***" version but supports the Partial Frame Buffer scheme.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_draw_point</b></em>   </td><td class="markdownTableBodyNone">Draw a 16bit pixel to a given tile. This function is relatively slower than the "***\_fast***" version but supports the Partial Frame Buffer scheme.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_draw_point</b></em>   </td><td class="markdownTableBodyNone">Draw a 32bit pixel to a given tile. This function is relatively slower than the "***\_fast***" version but supports the Partial Frame Buffer scheme.   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_fill_colour</b></em>   </td><td class="markdownTableBodyNone">Fill a given region inside a tile with a specified 8bit colour.   </td><td class="markdownTableBodyNone">This function can be used to draw vertical and horizontal lines.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_fill_colour</b></em>   </td><td class="markdownTableBodyNone">Fill a given region inside a tile with a specified 16bit colour.   </td><td class="markdownTableBodyNone">This function can be used to draw vertical and horizontal lines.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_fill_colour</b></em>   </td><td class="markdownTableBodyNone">Fill a given region inside a tile with a specified 32bit colour.   </td><td class="markdownTableBodyNone">This function can be used to draw vertical and horizontal lines.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_c8bit_draw_pattern</b></em>   </td><td class="markdownTableBodyNone">copy a bit-pattern (A1) to a target tile in 8bit colour   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb16_draw_pattern</b></em>   </td><td class="markdownTableBodyNone">copy a bit-pattern (A1) to a target tile in 16bit colour   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em><b>arm_2dp_rgb32_draw_pattern</b></em>   </td><td class="markdownTableBodyNone">copy a bit-pattern (A1) to a target tile in 32bit colour   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<h2><a class="anchor" id="autotoc_md64"></a>
3.6 Filters</h2>
<p >To be added in future versions. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <script type="text/javascript">
        <!--
        writeFooter.call(this);
        //-->
      </script> 
    </li>
  </ul>
</div>
</body>
</html>
